<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MiniCAD - US Feet Coordinate System</title>

<!-- Leaflet CSS & JS (for map functionality) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<!-- JSZip for KMZ export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- OCR and Screenshot Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
<!-- OpenCV.js for Image to CAD -->
<script async src="https://docs.opencv.org/4.5.2/opencv.js" id="opencv-script"></script>


<style>
  :root{
    --bg:#212830;--panel:#2c3440;--panel2:#3a4552;--text:#e6e9ef;--muted:#9aa4b2;--accent:#ff00ff;--osnap-marker:#f2ff00;
    --grip-active: #76a900;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; overflow: hidden;}
  .app{display:grid;grid-template-rows:auto 1fr 22px;grid-template-columns:260px 1fr;grid-template-areas:"toolbar toolbar" "sidebar canvas" "status status";height:100%}
  .toolbar{grid-area:toolbar;display:flex;flex-wrap: wrap;gap:8px;align-items:center;padding:6px 8px;background:linear-gradient(180deg,var(--panel),#282f3a);border-bottom:1px solid #1a1f26;position:sticky;top:0;z-index:15}
  .toolbar button,.toolbar .toggle {
  border:1px solid #4a5766;
  background:var(--panel2);
  color:var(--text);
  border-radius:10px;
  cursor:pointer; 
  font-size: 1em; 
  width: 30px; 
  height: 30px; /* Make the button a perfect square */
  padding: 0; /* Remove padding, as flexbox will handle alignment */

  /* --- Add these 3 lines for perfect centering --- */
  display: flex;
  align-items: center; /* This centers the icon vertically */
  justify-content: center; /* This centers the icon horizontally */
}
  .toolbar button.active{outline:2px solid var(--accent);}
  .toolbar button:hover{background:#4e5a6e;}
  .sidebar{grid-area:sidebar;display:flex;flex-direction:column;gap:10px;padding:10px;background:var(--panel);border-right:1px solid #1a1f26;overflow:auto}
  .card{background:var(--panel2);border:1px solid #4a5766;border-radius:14px;padding:10px}
  .card h3{margin:0 0 8px;font-size:14px;color:#c0d2ff}
  .row{display:flex;align-items:center;justify-content:space-between;margin:6px 0; gap: 8px;}
  .row input[type="color"], .row input[type="number"], .row select, .row input[type="text"] {background:#1e252e;color:var(--text);border:1px solid #4a5766;border-radius:8px;padding:6px; flex: 1; min-width: 0;}
  .row input[readonly] { background: #1a1f26; color: var(--muted); }
  .row select:disabled, .row input:disabled { background: #1a1f26; color: var(--muted); cursor: not-allowed; }
  .row label { flex-shrink: 0; width: 85px; font-size: 13px; }
  #newLayerName { flex: 1; min-width: 0; background:#1e252e;color:var(--text);border:1px solid #4a5766;border-radius:8px;padding:6px; }
  #layers .layer-row { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
  #layers .layer-row span { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
  #layers .layer-row input[type=checkbox] { width: 16px; height: 16px; }
  #addLayerBtn { font-size: o.5em; padding: 3px 5px; }


  /* Modelspace Area */
  .canvas-wrap{grid-area:canvas;position:relative;background:var(--bg);overflow:hidden; cursor: none;}
  #map{position:absolute;inset:0;z-index:0;background:#1b1f26;}
  canvas#cad{position:absolute;inset:0;z-index:1;display:block; background-color: transparent; pointer-events: auto; cursor: none;}

  /* Command Line */
  .commandline-wrap { position:absolute; left: 10px; bottom: 10px; right: 10px; z-index:10; }
  .command-history { background: rgba(30, 37, 46, 0.9); border:1px solid #4a5766; border-bottom: none; padding: 4px 8px; font-size: 13px; color: var(--muted); max-height: 100px; overflow-y: auto; display: none;}
  .commandline{display: flex; background:rgba(44, 52, 64, 0.95); border:1px solid #4a5766;border-radius:10px;padding: 8px 10px;}
  #prompt { color:#cbd5e1; white-space: pre;}
  .cmd-input {flex:1; background:transparent; border:none; outline:none; color:var(--text); font-family: ui-monospace,monospace; font-size: 14px;}

  /* Status Bar */
  .status{grid-area:status;display:flex;justify-content:space-between;align-items:center;padding:2px 8px;border-top:1px solid #1a1f26;background:#1e252e;color:var(--muted);font-size:12px; z-index: 16;}
  .status-chip{cursor:pointer; display:inline-flex;align-items:center;gap:6px;padding:1px 8px;border:1px solid transparent;border-radius:8px;}
  .status-chip.active{background:var(--accent);color:#fff; border-color:transparent;}
  .status-chip:hover{border-color:var(--muted);}
  .sep{height:24px;width:1px;background:#4a5766;margin:0 6px}
  .tooltip{position:fixed; pointer-events:none; background:#0b0f18e0; border:1px solid #4a5766; border-radius:8px; padding:4px 8px; font-size:12px; color:#b6c2cf; z-index:20; white-space: nowrap;}

  /* Context Menu */
  .context-menu {
      position: fixed;
      z-index: 1000;
      background: var(--panel);
      border: 1px solid #4a5766;
      border-radius: 8px;
      padding: 5px 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      display: none;
      min-width: 150px;
  }
  .context-menu button {
      display: block;
      width: 100%;
      padding: 8px 15px;
      text-align: left;
      border: none;
      background: none;
      color: var(--text);
      cursor: pointer;
  }
  .context-menu button:hover {
      background-color: var(--accent);
      color: #fff;
  }
    
  /* Modal Styles */
  .modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.5);
    z-index: 100; display: none; align-items: center; justify-content: center;
  }
  .modal-content {
    background: var(--panel); border: 1px solid #4a5766; border-radius: 14px;
    padding: 20px; width: 400px; box-shadow: 0 5px 20px rgba(0,0,0,0.4);
  }
  .modal-content h3 { margin-top: 0; color:#c0d2ff }
  .modal-content button {
    border:1px solid #4a5766;background:var(--panel2);color:var(--text);
    padding:6px 12px;border-radius:10px;cursor:pointer
  }
  .modal-content button:hover { background: #4e5a6e; }
  .modal-content input[type="range"] { flex: 1; }
  .modal-content .row label { width: 120px; }
  .modal-content textarea {
      width: 100%; height: 120px; background:#1e252e;color:var(--text);
      border:1px solid #4a5766;border-radius:8px;padding:8px; margin-bottom: 12px;
      resize: vertical;
  }

  /* Download Manager Styles */
  .download-options { display: flex; flex-direction: column; gap: 12px; }
  .download-options hr { width: 100%; border-color: #4a5766; border-style: solid; border-top: 0;}
  .download-row { display: flex; align-items: center; justify-content: space-between; font-size: 14px; gap: 15px;}
  .download-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;}
  .download-row select { background:#1e252e;color:var(--text);border:1px solid #4a5766;border-radius:8px;padding:6px; flex: 1; }
  .dl-coord-system { font-size: 12px; color: var(--muted); border: 1px solid #4a5766; padding: 4px 8px; border-radius: 8px; }
  .dl-coord-system button { background: none; border: none; color: var(--muted); cursor: pointer; }
  .download-row.data-section { color: var(--muted); justify-content: flex-start; margin-top: 10px; margin-bottom: -5px; }


</style>
</head>
<body>
  <div class="app">
    <div class="toolbar" id="toolbar">
       <!-- Drawing Commands -->
      <button id="toggleMapBtn" title="Show Satellite Map">üõ∞Ô∏è</button>
      <div class="sep"></div>
      <input type="text" id="searchCoordsInput" placeholder="Search for a location..." style="background:#1e252e;color:var(--text);border:1px solid #4a5766;border-radius:8px;padding:6px;width:220px;">
      <button id="searchCoordsBtn">üîé</button>
      <div class="sep"></div>
      <button data-command="line" title="Line (L)">‚Äî</button>
      <button data-command="polyline" title="Polyline (PL)">„Ä∞Ô∏è</button>
      <button data-command="circle" title="Circle (C)">‚ö™</button>
      <button data-command="rect" title="Rectangle (REC)">‚¨ú</button>
      <button data-command="text" title="Text (T)">üáπ</button>
      <button data-command="mtext" title="Multiline Text (MT)">üìÑ</button>
      <div class="sep"></div>
       <!-- Modify Commands -->
      <button data-command="erase" title="Erase (E)">üóëÔ∏è</button>
      <button data-command="move" title="Move (M)">‚ú•</button>
      <button data-command="copy" title="Copy (CO)">üìã</button>
      <button data-command="rotate" title="Rotate (RO)">üîÑ</button>
      <button data-command="scale" title="Scale (SC)">‚öñÔ∏è</button>
      <button data-command="stretch" title="Stretch (S)">‚≠§</button>
      <button data-command="mirror" title="Mirror (MI)">ü¶ã</button>
      <button data-command="offset" title="Offset (O)">‚Äñ</button>
      <button data-command="array" title="Array (AR)">‚ñ¶</button>
      <div class="sep"></div>
      <!-- Advanced Modify -->
      <button data-command="trim" title="Trim (TR)">‚úÇÔ∏è</button>
      <button data-command="extend" title="Extend (EX)">‚Ü¶</button>
      <button data-command="break" title="Break (BR)">‚®∞</button>
      <button data-command="join" title="Join (J)">üîó</button>
      <button data-command="fillet" title="Fillet (F)">‚åí</button>
      <button data-command="chamfer" title="Chamfer (CHA)">üìê</button>
      <button data-command="lengthen" title="Lengthen (LEN)">‚ÜîÔ∏è</button>
      <button data-command="explode" title="Explode (X)">üí•</button>
      <button data-command="matchprop" title="Match Properties (MA)">üñåÔ∏è</button>
      <div class="sep"></div>
       <!-- Inquiry & Utility -->
      <button data-command="distance" title="Distance (DI)">üìè</button>
      <button data-command="getaddress" title="Get Address (ADDR)">üìç</button>
      <button data-command="imagetext" title="Image Text (IT)">üî§</button>
      <button data-command="maptocad" title="Map to CAD (MTC)">üó∫Ô∏è</button>
      <div class="sep"></div>
      
      <button id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
       <div class="sep"></div>
      <button id="saveBtn" title="Save Drawing (JSON)">üíæ</button>
      <button id="openBtn" title="Open Drawing (JSON)">üìÇ</button>
      <input type="file" id="fileInput" accept=".json" style="display: none;" />
      <div class="sep"></div>
      <button id="exportKmzBtn" title="Export as KMZ">üåê</button>
      <button id="exportDxfBtn" title="Export as DXF (for AutoCAD)">üèóÔ∏è</button>
      <button id="downloadManagerBtn" title="Open Download Manager">‚¨áÔ∏è</button>
    </div>

    <div class="sidebar">
      <div class="card">
        <h3>Properties</h3>
        <div id="propertiesPanel">
            <!-- Generic Properties -->
            <div class="prop-group" id="propGeneric">
                <div class="row"><label for="propType">Selection</label><input type="text" id="propType" value="No selection" readonly></div>
                <div class="row"><label for="propColor">Color</label><input type="color" id="propColor" value="#e6e9ef"></div>
                <div class="row"><label for="propLayer">Layer</label><select id="propLayer"></select></div>
                <div class="row"><label for="propLinetype">Linetype</label><select id="propLinetype"></select></div>
                <div class="row"><label for="propLinetypeScale">Linetype scale</label><input type="number" id="propLinetypeScale" value="1.0" step="0.1"></div>
                <div class="row"><label for="propLineweight">Lineweight</label><select id="propLineweight"></select></div>
                <div class="row"><label for="propTransparency">Transparency</label><input type="number" id="propTransparency" value="0" min="0" max="90"></div>
                <div class="row"><label for="propThickness">Thickness</label><input type="number" id="propThickness" value="0.0" step="0.1"></div>
            </div>
            <!-- Text-Specific Properties -->
            <div class="prop-group" id="propText" style="display: none;">
                <div class="row"><label for="propTextType">Text</label><input type="text" id="propTextType" readonly></div>
                <div class="row"><label for="propTextLayer">Layer</label><select id="propTextLayer"></select></div>
                <div class="row"><label for="propTextColor">Color</label><input type="color" id="propTextColor"></div>
                <div class="row"><label for="propTextContent">Contents</label><input type="text" id="propTextContent"></div>
                <div class="row"><label for="propTextHeight">Height (ft)</label><input type="number" id="propTextHeight" value="10" step="0.1"></div>
                <div class="row"><label for="propTextRotation">Rotation</label><input type="number" id="propTextRotation" value="0" step="1"></div>
            </div>
        </div>
      </div>
      <div class="card">
        <h3>Layers</h3>
        <div id="layers"></div>
        <div class="row"><input id="newLayerName" placeholder="New layer name" /> <button id="addLayerBtn">‚ûï</button></div>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <div id="map"></div>
      <canvas id="cad"></canvas>
      <div class="tooltip" id="tooltip" style="display:none"></div>
      <div class="commandline-wrap">
          <div class="command-history" id="commandHistory"></div>
          <div class="commandline">
              <span id="prompt">Command: </span>
              <input class="cmd-input" id="cmd" autocomplete="off" />
          </div>
      </div>
    </div>

    <div class="context-menu" id="contextMenu">
        <!-- Menu items will be added here dynamically -->
    </div>

    <div class="status">
      <div id="cursorPos">X: 0.00 ft, Y: 0.00 ft</div>
      <div>
        <span class="status-chip" id="gridToggle" title="Toggle Grid (F7)">Grid</span>
        <span class="status-chip" id="orthoToggle" title="Toggle Ortho (F8)">Ortho</span>
        <span class="status-chip active" id="osnapToggle" title="Toggle Object Snap (F3)">Osnap</span>
      </div>
    </div>
  </div>

  <div id="vectorizeModal" class="modal-backdrop">
    <div class="modal-content">
        <h3>Image Vectorization Settings</h3>
        <div class="row">
            <label for="cannyThreshold1">Canny Threshold 1</label>
            <input type="range" id="cannyThreshold1" min="0" max="255" value="50">
            <span id="cannyThreshold1Value">50</span>
        </div>
        <div class="row">
            <label for="cannyThreshold2">Canny Threshold 2</label>
            <input type="range" id="cannyThreshold2" min="0" max="255" value="150">
            <span id="cannyThreshold2Value">150</span>
        </div>
        <div class="row">
            <label for="epsilon">Simplification</label>
            <input type="range" id="epsilon" min="0.1" max="10" step="0.1" value="2.0">
            <span id="epsilonValue">2.0</span>
        </div>
        <div class="row" style="justify-content: flex-end; gap: 12px;">
            <button id="cancelVectorizeBtn">Cancel</button>
            <button id="startVectorizeBtn">Trace Image</button>
        </div>
    </div>
  </div>

  <div id="mtextModal" class="modal-backdrop">
      <div class="modal-content">
          <h3>Multiline Text</h3>
          <textarea id="mtextInput"></textarea>
          <div class="row" style="justify-content: flex-end; gap: 12px;">
              <button id="cancelMtextBtn">Cancel</button>
              <button id="saveMtextBtn">OK</button>
          </div>
      </div>
  </div>

  <div id="downloadManagerModal" class="modal-backdrop">
    <div class="modal-content" style="width: 500px;">
        <h3><span style="display:inline-block; transform: rotate(90deg);">&#x2913;</span> DOWNLOAD MANAGER</h3>
        <div class="download-options">
            <div class="download-row">
                <label><input type="checkbox" id="dl-gis" checked> GIS Shapefile</label>
                <label><input type="checkbox" id="dl-split" checked> Split by Type</label>
                <div class="dl-coord-system">Latitude / Longitude (WGS 84) <button>&times;</button></div>
            </div>
            <div class="download-row">
                <label><input type="checkbox" id="dl-kmz"> Google Earth KMZ</label>
            </div>
            <div class="download-row">
                <label><input type="checkbox" id="dl-dxf"> AutoCAD DXF</label>
            </div>
            <div class="download-row">
                <label><input type="checkbox" id="dl-geojson"> GeoJSON</label>
            </div>
             <hr>
             <div class="download-row data-section">
                <strong>DATA</strong>
             </div>
             <div class="download-row">
                <label for="dl-spreadsheet">Spreadsheet Exports:</label>
                <select id="dl-spreadsheet" disabled><option>Select an Export</option></select>
             </div>
             <div class="download-row">
                <label for="dl-pdf">PDF Form Exports:</label>
                <select id="dl-pdf" disabled><option>Select an Export</option></select>
             </div>
             <div class="download-row">
                <label><input type="checkbox" id="dl-jobjson"> Job JSON</label>
             </div>
        </div>
        <div class="row" style="justify-content: flex-end; gap: 12px; margin-top: 20px;">
            <button id="cancelDownloadBtn">Cancel</button>
            <button id="filterDownloadBtn">Filter And Download</button>
        </div>
    </div>
  </div>


<script>
(() => {
  // --- DOM ELEMENTS ---
  const canvas = document.getElementById('cad');
  const ctx = canvas.getContext('2d');
  const cmdInput = document.getElementById('cmd');
  const promptEl = document.getElementById('prompt');
  const tooltip = document.getElementById('tooltip');
  const cursorPosEl = document.getElementById('cursorPos');
  const layersDiv = document.getElementById('layers');
  const fileInput = document.getElementById('fileInput');
  const contextMenu = document.getElementById('contextMenu');
  const propertiesPanel = document.getElementById('propertiesPanel');


  // --- GLOBAL STATE ---
  let isCvReady = false;
  const state = {
    ents: [],
    layers: [{name:'0', color:'#e6e9ef', visible:true, locked:false}],
    linetypes: [
        { name: 'ByLayer', pattern: [] },
        { name: 'Continuous', pattern: [] },
        { name: 'Dashed', pattern: [10, 5] },
        { name: 'Dotted', pattern: [2, 4] },
        { name: 'Dash-Dot', pattern: [10, 5, 2, 5] },
    ],
    lineweights: [
        'ByLayer', 'Default', '0.05', '0.09', '0.13', '0.15', '0.18', '0.20', '0.25', '0.30', '0.35', '0.40', '0.50', '0.60', '0.70', '0.80', '0.90', '1.00', '1.20', '1.50', '2.00'
    ],
    currentLayer: '0',
    selection: [],
    history: [],
    future: [],
    grid: true,
    ortho: false,
    osnap: true,
    mouse: {x:0, y:0, worldX:0, worldY:0, isDown:false, isPanning:false, lastX:0, lastY:0, lastClickTime: 0},
    activeCommand: null,
    commandHistory: [],
    lastCommand: null,
    snapPoint: null,
    activeGrip: null,
    selectionBox: null,
    currentProperties: {
        color: 'ByLayer',
        linetype: 'ByLayer',
        lineweight: 'ByLayer',
        linetypeScale: 1.0,
        transparency: 0,
        thickness: 0.0,
    },
    clipboard: { data: [], basePoint: null },
    viewHistory: [],
    isZoomingProgrammatically: false
  };
  let nextId = 1;

  // --- MAP & VIEW STATE ---
  let leafletMap = null;
  let mapTileLayerSatellite = null;
  let mapTileLayerStreet = null;
  let mapState = 0; // 0: Off, 1: Satellite, 2: Street
  
  // --- CORRECTED COORDINATE SYSTEM STATE ---
  const METERS_TO_FEET = 3.2808399; // U.S. Survey Foot
  const FEET_TO_METERS = 1 / METERS_TO_FEET;
  let cadOrigin = null; // { lat, lng }
  let feetPerDegree = null; // { lat, lng }


  // --- INITIALIZATION ---
  function init() {
      resize();
      initMap();
      setCadOrigin(); // CRITICAL: Establish the local coordinate system
      populateStaticSelects();
      bindEvents();
      refreshLayersUI();
      updatePropertiesPanel();
      updateStatusBar();
      snapshot();
      draw();
      cmdInput.focus();
      document.getElementById('opencv-script').onload = () => {
          isCvReady = true;
          console.log("OpenCV.js is ready.");
          logToHistory("Map to CAD engine loaded.");
      };
  }

  function setCadOrigin() {
      cadOrigin = leafletMap.getCenter();
      
      const p1 = cadOrigin;
      const p2_lat = L.latLng(p1.lat + 1, p1.lng);
      const p2_lng = L.latLng(p1.lat, p1.lng + 1);
      
      const dist_lat_meters = leafletMap.options.crs.distance(p1, p2_lat);
      const dist_lng_meters = leafletMap.options.crs.distance(p1, p2_lng);

      feetPerDegree = {
          lat: dist_lat_meters * METERS_TO_FEET,
          lng: dist_lng_meters * METERS_TO_FEET
      };
      console.log("CAD Origin Set:", cadOrigin);
      console.log("Scale Factors (ft/degree):", feetPerDegree);
      logToHistory("Local coordinate system established in U.S. Survey Feet.");
  }

   function populateStaticSelects() {
        const linetypeSelect = document.getElementById('propLinetype');
        state.linetypes.forEach(lt => {
            const opt = document.createElement('option');
            opt.value = lt.name;
            opt.textContent = lt.name;
            linetypeSelect.appendChild(opt);
        });

        const lineweightSelect = document.getElementById('propLineweight');
        state.lineweights.forEach(lw => {
            const opt = document.createElement('option');
            opt.value = lw;
            opt.textContent = lw;
            lineweightSelect.appendChild(opt);
        });
    }

  function initMap() {
    leafletMap = L.map('map', {
        zoomControl: false,
        attributionControl: false,
    }).setView([40.7128, -74.0060], 13);

    mapTileLayerSatellite = L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
        maxZoom: 21,
        subdomains:['mt0','mt1','mt2','mt3'],
        attribution: '&copy; Google Maps'
    });
    
    mapTileLayerStreet = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
        maxZoom: 21,
        subdomains:['mt0','mt1','mt2','mt3'],
        attribution: '&copy; Google Maps'
    });

    leafletMap.on('move', draw);
    leafletMap.on('zoom', draw);
  }

  // =======================================================
  // SECTION: COORDINATE SYSTEM & GEOMETRY (FEET-BASED)
  // =======================================================
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const distScreen = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);

  function screenToWorld(p_screen) {
      if (!leafletMap || !cadOrigin) return { x: 0, y: 0 };
      const latLng = leafletMap.containerPointToLatLng(p_screen);
      const dLat = latLng.lat - cadOrigin.lat;
      const dLng = latLng.lng - cadOrigin.lng;
      return { x: dLng * feetPerDegree.lng, y: dLat * feetPerDegree.lat };
  }

  function worldToScreen(p_world_ft) {
      if (!leafletMap || !cadOrigin) return { x: 0, y: 0 };
      const dLat = p_world_ft.y / feetPerDegree.lat;
      const dLng = p_world_ft.x / feetPerDegree.lng;
      const targetLatLng = { lat: cadOrigin.lat + dLat, lng: cadOrigin.lng + dLng };
      return leafletMap.latLngToContainerPoint(targetLatLng);
  }

  function getDestinationPoint(startPoint_ft, distance_ft, bearing_deg) {
    const bearing_rad = bearing_deg * Math.PI / 180;
    const dx = distance_ft * Math.sin(bearing_rad);
    const dy = distance_ft * Math.cos(bearing_rad);
    return { x: startPoint_ft.x + dx, y: startPoint_ft.y + dy };
  }

  function getBearing(p1_ft, p2_ft) {
      const dx = p2_ft.x - p1_ft.x;
      const dy = p2_ft.y - p1_ft.y;
      const angleRad = Math.atan2(dx, dy);
      const angleDeg = (angleRad * 180 / Math.PI + 360) % 360;
      return angleDeg;
  }

  function orthoPoint(from_ft, to_ft) {
    const dx = Math.abs(to_ft.x - from_ft.x);
    const dy = Math.abs(to_ft.y - from_ft.y);
    if (dx > dy) {
        return { x: to_ft.x, y: from_ft.y };
    } else {
        return { x: from_ft.x, y: to_ft.y };
    }
  }

  function transformPoints(ent, transformFunc) {
      if (ent.type === 'line') {
          ent.a = transformFunc(ent.a);
          ent.b = transformFunc(ent.b);
      } else if (ent.type === 'circle') {
          ent.c = transformFunc(ent.c);
      } else if (ent.type === 'polyline') {
          ent.pts = ent.pts.map(transformFunc);
      } else if (ent.type === 'text' || ent.type === 'mtext') {
          ent.insertionPoint = transformFunc(ent.insertionPoint);
      }
  }

    function closestPointOnLineWorld(p_world, a_world, b_world) {
        const atob = { x: b_world.x - a_world.x, y: b_world.y - a_world.y };
        const atop = { x: p_world.x - a_world.x, y: p_world.y - a_world.y };
        const len_sq = atob.x * atob.x + atob.y * atob.y;
        if (len_sq < 1e-9) return a_world; // Avoid division by zero for tiny segments
        let t = (atop.x * atob.x + atop.y * atob.y) / len_sq;
        t = Math.max(0, Math.min(1, t)); // Clamp t to ensure the point is on the segment
        return { x: a_world.x + atob.x * t, y: a_world.y + atob.y * t };
    }

    function intersectLineLineScreen(p1, p2, p3, p4, extendLines = false) {
        const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        if (Math.abs(d) < 1e-9) return null; // Parallel or collinear
        const t = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
        const u = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;

        if (!extendLines && (t < -1e-9 || t > 1 + 1e-9 || u < -1e-9 || u > 1 + 1e-9)) {
            return null; // No intersection on segments
        }
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }

    function reflectPointScreen(p, p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        if(dx === 0 && dy === 0) return p;
        const a = (dx * dx - dy * dy) / (dx * dx + dy * dy);
        const b = 2 * dx * dy / (dx * dx + dy * dy);
        const x = a * (p.x - p1.x) + b * (p.y - p1.y) + p1.x;
        const y = b * (p.x - p1.x) - a * (p.y - p1.y) + p1.y;
        return { x, y };
    }

    function pointsAreEqual(p1, p2, tolerance = 1e-9) {
      return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;
    }

  // =======================================================
  // SECTION: CORE COMMAND ENGINE
  // =======================================================

  const commands = {
    'line': { alias: 'l', execute: startLineCommand, prompt: "Specify first point:" },
    'circle': { alias: 'c', execute: startCircleCommand, prompt: "Specify center point:" },
    'rect': { alias: 'rec', execute: startRectCommand, prompt: "Specify first corner:" },
    'polyline': { alias: 'pl', execute: startPolylineCommand, prompt: "Specify start point:" },
    'text': { alias: 't', execute: startTextCommand, prompt: "Specify insertion point:" },
    'mtext': { alias: 'mt', execute: startMtextCommand, prompt: "Specify first corner of text box:" },
    'erase': { alias: 'e', execute: startEraseCommand, prompt: "Select objects:" },
    'offset': { alias: 'o', execute: startOffsetCommand, prompt: "Specify offset distance (feet):" },
    'move': { alias: 'm', execute: startMoveCommand, prompt: "Specify base point:" },
    'copy': { alias: 'co', execute: startCopyCommand, prompt: "Specify base point:" },
    'paste': { alias: 'paste', execute: startPasteCommand, prompt: "Specify insertion point:" },
    'rotate': { alias: 'ro', execute: startRotateCommand, prompt: "Specify base point:" },
    'scale': { alias: 'sc', execute: startScaleCommand, prompt: "Specify base point:" },
    'distance': { alias: 'di', execute: startDistanceCommand, prompt: "Specify first point:" },
    'getaddress': { alias: 'addr', execute: startGetAddressCommand, prompt: "Select a closed polyline or specify a point:" },
    'imagetext': { alias: 'it', execute: startImageTextCommand, prompt: "Specify first corner of text area:" },
    'maptocad': { alias: 'mtc', execute: startMapToCadCommand, prompt: "Specify first corner of boundary:" },
    'mirror': { alias: 'mi', execute: startMirrorCommand, prompt: "Specify first point of mirror line:" },
    'stretch': { alias: 's', execute: startStretchCommand, prompt: "Select objects to stretch by crossing-window..." },
    'trim': { alias: 'tr', execute: startTrimCommand, prompt: "Select cutting edges... Then press Enter." },
    'extend': { alias: 'ex', execute: startExtendCommand, prompt: "Select boundary edges... Then press Enter." },
    'fillet': { alias: 'f', execute: startFilletCommand, prompt: "Specify fillet radius (feet):" },
    'chamfer': { alias: 'cha', execute: startChamferCommand, prompt: "Specify first chamfer distance (feet):" },
    'join': { alias: 'j', execute: startJoinCommand, prompt: "Select objects to join:" },
    'explode': { alias: 'x', execute: startExplodeCommand, prompt: "Select objects to explode:" },
    'matchprop': { alias: 'ma', execute: startMatchpropCommand, prompt: "Select source object:" },
    'break': { alias: 'br', execute: startBreakCommand, prompt: "Select object to break:" },
    'lengthen': { alias: 'len', execute: startLengthenCommand, prompt: "Enter delta distance (feet):" },
    'array': { alias: 'ar', execute: startArrayCommand, prompt: "Enter number of rows:" },
    'zoom': { alias: 'z', execute: startZoomCommand, prompt: "Enter an option [Extents/Window/Previous/Object]:" }
  };

  function runCommand(cmdStr) {
    cancelGripEdit();
    if (!cmdStr) { if(state.lastCommand) runCommand(state.lastCommand.name); return; }
    const args = cmdStr.toLowerCase().trim().split(' ');
    const cmdName = args[0];
    let command, officialName;
    for(const name in commands) { if(name === cmdName || commands[name].alias === cmdName) { command = commands[name]; officialName = name; break; } }

    if (command){
        logToHistory(`Command: ${officialName}`);
        state.activeCommand = { name: officialName, step: 0, data: {}, prompt: command.prompt };
        if (officialName !== 'paste') state.lastCommand = state.activeCommand;
        setPrompt(command.prompt);
        command.execute();
        draw();
    } else { logToHistory(`Unknown command "${cmdName}".`); }
  }

  function completeCommand() { state.activeCommand = null; clearSelection(); setPrompt("Command: "); draw(); }
  function cancelCommand() { if(state.activeCommand) logToHistory("*Cancel*"); state.activeCommand = null; clearSelection(); cancelGripEdit(); setPrompt("Command: "); draw(); }
  function setPrompt(text) { promptEl.textContent = text ? `${text} ` : "Command: "; if (text) showTooltip(text); else hideTooltip(); }
  function logToHistory(text) { const historyEl = document.getElementById('commandHistory'); historyEl.style.display = 'block'; historyEl.innerHTML += `<div>${text}</div>`; historyEl.scrollTop = historyEl.scrollHeight; }

  // =======================================================
  // SECTION: SPECIFIC COMMAND IMPLEMENTATIONS
  // =======================================================
   function startTextCommand() {
    const cmd = state.activeCommand;
    cmd.data.height = 10.0; // Default world height in feet
    cmd.data.rotation = 0;   // Default rotation

    cmd.execute = () => {
        switch(cmd.step) {
            case 0: // Get insertion point
                const pt = getPointInput();
                if(pt) {
                    cmd.data.insertionPoint = pt;
                    setPrompt(`Specify height <${cmd.data.height.toFixed(1)} ft>:`);
                    cmd.step = 1;
                }
                break;
            case 1: // Get height by clicking
                const heightPt = getPointInput();
                if (heightPt) {
                    const dist = Math.hypot(heightPt.x - cmd.data.insertionPoint.x, heightPt.y - cmd.data.insertionPoint.y);
                    cmd.data.height = dist;
                    logToHistory(`Height: ${cmd.data.height.toFixed(2)} ft`);
                    setPrompt(`Specify rotation angle <${cmd.data.rotation}>:`);
                    cmd.step = 2;
                }
                break;
            case 2: // Get rotation by clicking
                const rotPt = getPointInput();
                if (rotPt) {
                    cmd.data.rotation = getBearing(cmd.data.insertionPoint, rotPt);
                    logToHistory(`Rotation: ${cmd.data.rotation.toFixed(2)}`);
                    cmd.step = 3;
                    cmd.execute();
                }
                break;
            case 3: // Get content
                 const textString = prompt("Enter text:", "");
                 if (textString) {
                     pushEnt({
                         type: 'text',
                         insertionPoint: cmd.data.insertionPoint,
                         textString: textString,
                         height: cmd.data.height,
                         rotation: cmd.data.rotation,
                         layer: state.currentLayer,
                         props: curProps()
                     });
                 }
                 completeCommand();
                 break;
        }
    };
    cmd.processInput = (input) => {
        if (input.trim() === '') { // User pressed enter to accept default
            if (cmd.step === 1) { // Accept default height
                 setPrompt(`Specify rotation angle <${cmd.data.rotation}>:`);
                 cmd.step = 2;
            } else if (cmd.step === 2) { // Accept default rotation
                cmd.step = 3;
                cmd.execute();
            }
            return;
        }
        
        const num = parseFloat(input);
        if(isNaN(num)) { logToHistory("Invalid input."); return; }

        if(cmd.step === 1) { // Processing height from command line
            cmd.data.height = num;
            logToHistory(`Height: ${num} ft`);
            setPrompt(`Specify rotation angle <${cmd.data.rotation}>:`);
            cmd.step = 2;
            cmdInput.value = '';
        } else if (cmd.step === 2) { // Processing rotation from command line
            cmd.data.rotation = num;
            logToHistory(`Rotation: ${num}`);
            cmd.step = 3;
            cmd.execute();
        }
    };
   }

  function startMtextCommand() {
      const cmd = state.activeCommand;
      cmd.execute = () => {
          switch (cmd.step) {
              case 0:
                  const p1 = getPointInput();
                  if (p1) {
                      cmd.data.p1 = p1;
                      setPrompt("Specify other corner of text box:");
                      cmd.step++;
                  }
                  break;
              case 1:
                  const p2 = getPointInput();
                  if (p2) {
                      cmd.data.p2 = p2;
                      const mtextModal = document.getElementById('mtextModal');
                      const mtextInput = document.getElementById('mtextInput');
                      mtextInput.value = '';
                      mtextModal.style.display = 'flex';
                      mtextInput.focus();
                  }
                  break;
          }
      };
  }

  async function fetchAndPlaceAddress(pointInFeet) {
    logToHistory("Fetching address...");
    
    // Convert our internal feet coordinates back to Lat/Lon for the API call
    const dLat = pointInFeet.y / feetPerDegree.lat;
    const dLng = pointInFeet.x / feetPerDegree.lng;
    const latLng = { lat: cadOrigin.lat + dLat, lng: cadOrigin.lng + dLng };

    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latLng.lat}&lon=${latLng.lng}&zoom=18&addressdetails=1`;
    try {
        const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if (!response.ok) throw new Error('Network error');
        const data = await response.json();

        if (data && data.display_name) {
            const address = data.display_name;
            logToHistory(`Address found: ${address}`);
            pushEnt({
                type: 'text',
                insertionPoint: pointInFeet, // Use the original point in feet
                textString: address,
                height: 10.0, // Default world height in feet
                rotation: 0,
                layer: state.currentLayer,
                props: curProps()
            });
        } else {
            logToHistory("Could not retrieve address for this location.");
        }
    } catch (error) {
        logToHistory(`Error fetching address: ${error.message}`);
        console.error("Reverse geocoding failed:", error);
    }
  }

  function startGetAddressCommand() {
    const cmd = state.activeCommand;
    cmd.execute = async () => {
        let targetPoint = null;
        const hit = hitTest(getPointInput(true));

        if (hit && hit.type === 'polyline' && hit.closed) {
            let avgX = 0, avgY = 0;
            const uniquePts = hit.pts.slice(0, -1);
            for (const pt of uniquePts) {
                avgX += pt.x;
                avgY += pt.y;
            }
            targetPoint = { x: avgX / uniquePts.length, y: avgY / uniquePts.length };
            logToHistory("Polyline selected. Fetching address for its centroid.");
        } else {
            targetPoint = getPointInput();
            logToHistory("Point selected. Fetching address.");
        }

        if (targetPoint) {
            await fetchAndPlaceAddress(targetPoint);
        }
        completeCommand();
    };
  }

  // --- OCR Command Implementation ---
  function startImageTextCommand() {
      if (mapState !== 2) { // Works best with clean street maps
          logToHistory("Image Text command requires the Street Map to be active. Please switch maps and try again.");
          cancelCommand();
          return;
      }

      const cmd = state.activeCommand;
      cmd.execute = () => {
          switch (cmd.step) {
              case 0:
                  const p1 = getPointInput();
                  if (p1) {
                      cmd.data.p1_screen = worldToScreen(p1);
                      setPrompt("Specify second corner:");
                      cmd.step++;
                  }
                  break;
              case 1:
                  const p2 = getPointInput();
                  if (p2) {
                      cmd.data.p2_screen = worldToScreen(p2);
                      performOcrOnArea(cmd.data.p1_screen, cmd.data.p2_screen);
                      completeCommand();
                  }
                  break;
          }
      };
  }

  async function performOcrOnArea(p1_s, p2_s) {
      if (typeof html2canvas === 'undefined' || typeof Tesseract === 'undefined') {
          logToHistory("Error: Required libraries (html2canvas or Tesseract.js) are not loaded.");
          return;
      }
      logToHistory("Capturing map area for OCR...");

      const rect = {
          x: Math.min(p1_s.x, p2_s.x),
          y: Math.min(p1_s.y, p2_s.y),
          width: Math.abs(p1_s.x - p2_s.x),
          height: Math.abs(p1_s.y - p2_s.y)
      };

      if (rect.width < 10 || rect.height < 10) {
          logToHistory("Selected area is too small for OCR.");
          return;
      }

      try {
          const mapElement = document.getElementById('map');
          const canvas = await html2canvas(mapElement, { useCORS: true, logging: false });

          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = rect.width;
          cropCanvas.height = rect.height;
          const cropCtx = cropCanvas.getContext('2d');
          cropCtx.drawImage(canvas, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
          
          const imageForOcr = cropCanvas.toDataURL();

          logToHistory("Recognizing text... (this may take a moment)");
          const worker = await Tesseract.createWorker('eng');
          const { data: { lines } } = await worker.recognize(imageForOcr);
          await worker.terminate();

          if (lines.length === 0) {
              logToHistory("No text found in the selected area.");
              return;
          }

          logToHistory(`Found ${lines.length} line(s) of text.`);
          let createdCount = 0;

          lines.forEach(line => {
              if (line.confidence < 50) return;
              
              const bbox = line.bbox;
              const centerX_screen = rect.x + (bbox.x0 + bbox.x1) / 2;
              const centerY_screen = rect.y + (bbox.y0 + bbox.y1) / 2;
              const insertionPoint_world = screenToWorld({ x: centerX_screen, y: centerY_screen });
              
              const topOfText_screen = {x: centerX_screen, y: centerY_screen - bbox.height};
              const topOfText_world = screenToWorld(topOfText_screen);

              const worldHeight = Math.hypot(insertionPoint_world.x - topOfText_world.x, insertionPoint_world.y - topOfText_world.y);

              pushEnt({
                  type: 'text',
                  textString: line.text.trim(),
                  insertionPoint: insertionPoint_world,
                  height: worldHeight,
                  rotation: 0,
                  layer: state.currentLayer,
                  props: curProps()
              });
              createdCount++;
          });

          if (createdCount > 0) {
              logToHistory(`Created ${createdCount} text object(s).`);
              snapshot();
              draw();
          } else {
              logToHistory("No text with sufficient confidence was found.");
          }

      } catch (err) {
          logToHistory("Error during OCR process. See console for details.");
          console.error("Image Text Error:", err);
      }
  }

  // --- MAP TO CAD COMMAND ---
  function startMapToCadCommand() {
    if (!isCvReady) {
        logToHistory("Map to CAD engine (OpenCV.js) is still loading. Please wait a moment and try again.");
        cancelCommand();
        return;
    }
    if (mapState !== 2) {
        logToHistory("Map to CAD command requires the Google Street Map to be active. Please switch maps and try again.");
        cancelCommand();
        return;
    }

    const cmd = state.activeCommand;
    cmd.execute = () => {
        switch (cmd.step) {
            case 0:
                const p1 = getPointInput();
                if (p1) {
                    cmd.data.p1_screen = worldToScreen(p1);
                    setPrompt("Specify second corner of boundary:");
                    cmd.step++;
                }
                break;
            case 1:
                const p2 = getPointInput();
                if (p2) {
                    cmd.data.p2_screen = worldToScreen(p2);
                    document.getElementById('vectorizeModal').style.display = 'flex';
                }
                break;
        }
    };
  }

  async function performMapVectorization() {
    if (!state.activeCommand || state.activeCommand.name !== 'maptocad') return;

    const { p1_screen, p2_screen } = state.activeCommand.data;
    const t1 = parseInt(document.getElementById('cannyThreshold1').value);
    const t2 = parseInt(document.getElementById('cannyThreshold2').value);
    const epsilon = parseFloat(document.getElementById('epsilon').value);

    logToHistory(`Starting vectorization... T1:${t1}, T2:${t2}, E:${epsilon}`);
    setPrompt("Processing image... Please wait.");

    const rect = {
        x: Math.min(p1_screen.x, p2_screen.x),
        y: Math.min(p1_screen.y, p2_screen.y),
        width: Math.abs(p1_screen.x - p2_screen.x),
        height: Math.abs(p1_screen.y - p2_screen.y)
    };

    if (rect.width < 10 || rect.height < 10) {
        logToHistory("Selected boundary is too small.");
        completeCommand();
        return;
    }

    let src, gray, edges, contours, hierarchy;
    try {
        const mapElement = document.getElementById('map');
        const fullCanvas = await html2canvas(mapElement, { useCORS: true, logging: false });
        
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = rect.width;
        cropCanvas.height = rect.height;
        const cropCtx = cropCanvas.getContext('2d');
        cropCtx.drawImage(fullCanvas, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
        
        src = cv.imread(cropCanvas);
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
        
        edges = new cv.Mat();
        cv.Canny(gray, edges, t1, t2, 3, false);
        
        contours = new cv.MatVector();
        hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        let createdCount = 0;
        for (let i = 0; i < contours.size(); ++i) {
            const cnt = contours.get(i);
            const area = cv.contourArea(cnt, false);
            if (area < 20) continue; 

            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, epsilon, true);

            const points_w = [];
            for (let j = 0; j < approx.data32S.length; j += 2) {
                const px = approx.data32S[j];
                const py = approx.data32S[j+1];
                const screenPt = { x: rect.x + px, y: rect.y + py };
                points_w.push(screenToWorld(screenPt));
            }

            if (points_w.length > 1) {
                pushEnt({
                    type: 'polyline',
                    pts: points_w,
                    closed: false,
                    layer: state.currentLayer,
                    props: curProps()
                });
                createdCount++;
            }
            approx.delete();
        }

        snapshot();
        logToHistory(`Vectorization complete. Created ${createdCount} polylines.`);
    } catch (err) {
        logToHistory("Error during vectorization. See console for details.");
        console.error("Vectorization Error:", err);
    } finally {
        if (src) src.delete();
        if (gray) gray.delete();
        if (edges) edges.delete();
        if (contours) contours.delete();
        if (hierarchy) hierarchy.delete();
    }
    completeCommand();
  }


  function startLineCommand() {
    const cmd = state.activeCommand;
    cmd.execute = () => {
      switch (cmd.step) {
        case 0: const pt = getPointInput(); if (pt) { cmd.data.start = pt; setPrompt("Specify next point:"); cmd.step++; } break;
        case 1: const endPt = getPointInput(); if (endPt) { pushEnt({type:'line', a:cmd.data.start, b:endPt, layer:state.currentLayer, props:curProps()}); cmd.data.start = endPt; } break;
      }
    };
  }

  function startCircleCommand() {
      const cmd = state.activeCommand;
      cmd.execute = () => {
          switch (cmd.step) {
              case 0: const center = getPointInput(); if (center) { cmd.data.center = center; setPrompt("Specify radius of circle (feet):"); cmd.step++; } break;
              case 1:
                  const radiusPt = getPointInput();
                  if (radiusPt) {
                      const radiusInFeet = Math.hypot(radiusPt.x - cmd.data.center.x, radiusPt.y - cmd.data.center.y);
                      pushEnt({type:'circle', c:cmd.data.center, r:radiusInFeet, layer:state.currentLayer, props:curProps()});
                      completeCommand();
                  }
                  break;
          }
      };
  }

  function startRectCommand() {
    const cmd = state.activeCommand;
    cmd.execute = () => {
        switch (cmd.step) {
            case 0: const c1 = getPointInput(); if(c1) { cmd.data.start = c1; setPrompt("Specify other corner point:"); cmd.step++; } break;
            case 1:
                const c2 = getPointInput();
                if(c2) {
                    const p1 = cmd.data.start; const p3 = c2;
                    const p2 = { x: p3.x, y: p1.y }; const p4 = { x: p1.x, y: p3.y };
                    pushEnt({type:'polyline', pts:[p1,p2,p3,p4,p1], closed: true, layer:state.currentLayer, props:curProps()});
                    completeCommand();
                }
                break;
        }
    };
  }

  function startPolylineCommand() {
      const cmd = state.activeCommand;
      cmd.data.points = [];

      const updatePolyPrompt = () => {
          if (cmd.data.points.length === 0) {
              setPrompt("Specify start point:");
          } else if (cmd.data.points.length > 1) {
              setPrompt("Specify next point or [Close/Undo]:");
          } else {
              setPrompt("Specify next point or [Undo]:");
          }
      };

      cmd.execute = () => {
          const pt = getPointInput();
          if (pt) {
              cmd.data.points.push(pt);
              updatePolyPrompt();
          }
      };

      cmd.processSubCommand = (input) => {
          const option = input.toLowerCase().trim();
          if (option === 'c' && cmd.data.points.length > 2) {
              const finalPoints = [...cmd.data.points, cmd.data.points[0]];
              pushEnt({type: 'polyline', pts: finalPoints, closed: true, layer: state.currentLayer, props: curProps()});
              logToHistory("Polyline closed.");
              completeCommand();
          } else if (option === 'u' && cmd.data.points.length > 0) {
              cmd.data.points.pop();
              logToHistory("Last segment undone.");
              updatePolyPrompt();
              draw();
          } else if (option === '') {
              if (cmd.data.points.length > 1) {
                  pushEnt({type:'polyline', pts: cmd.data.points, closed: false, layer: state.currentLayer, props: curProps()});
              }
              completeCommand();
          } else {
              logToHistory(`Unknown option "${option}".`);
          }
      };

      updatePolyPrompt();
  }


  function startEraseCommand() {
      if (state.selection.length > 0) {
          deleteSelection();
      } else {
         logToHistory("Nothing selected to erase.");
      }
      completeCommand();
  }

  // =======================================================
  // SECTION: FIXED & IMPLEMENTED COMMANDS
  // =======================================================

  function startOffsetCommand() {
    const cmd = state.activeCommand;
    cmd.data = {};

    cmd.processInput = (input) => {
        if (cmd.step === 0) {
            const dist = parseFloat(input);
            if (!isNaN(dist) && dist !== 0) {
                cmd.data.distance = Math.abs(dist); // Distance is in feet
                logToHistory(`Offset distance: ${Math.abs(dist)} ft`);
                setPrompt("Select object to offset:");
                cmd.step = 1;
            } else {
                logToHistory(`Invalid distance "${input}".`);
                setPrompt("Specify offset distance (feet):");
            }
        }
    };

    cmd.execute = () => {
        if (cmd.step === 1) {
            const hit = hitTest(getPointInput(true));
            if (hit) {
                cmd.data.selectedEnt = hit;
                logToHistory("Object selected.");
                setPrompt("Specify point on side to offset:");
                cmd.step = 2;
            }
        } else if (cmd.step === 2) {
            const sidePoint = getPointInput();
            const sourceEnt = cmd.data.selectedEnt;
            if (!sourceEnt) { cancelCommand(); return; }

            let newEnt = null;

            if (sourceEnt.type === 'circle') {
                const distToCenter = Math.hypot(sidePoint.x - sourceEnt.c.x, sidePoint.y - sourceEnt.c.y);
                const sign = distToCenter > sourceEnt.r ? 1 : -1;
                const newRadius = sourceEnt.r + (cmd.data.distance * sign);

                if (newRadius > 0) {
                  newEnt = {
                      type: 'circle', c: sourceEnt.c, r: newRadius,
                      layer: sourceEnt.layer, props: { ...sourceEnt.props }
                  };
                } else {
                  logToHistory("Offset results in an invalid circle radius.");
                }
            } else if (sourceEnt.type === 'line' || sourceEnt.type === 'polyline') {
                const isClosed = sourceEnt.closed || false;
                let pts_w = sourceEnt.type === 'line' ? [sourceEnt.a, sourceEnt.b] : [...sourceEnt.pts];
                if (isClosed && pts_w.length > 1 && pointsAreEqual(pts_w[0], pts_w[pts_w.length - 1])) {
                    pts_w.pop();
                }
                if (pts_w.length < 2) { cancelCommand(); return; }
                
                // --- START: MODIFIED LOGIC TO FIND CORRECT OFFSET SIDE ---
                let closest_seg_p1 = null;
                let closest_seg_p2 = null;
                let min_dist_sq = Infinity;
                
                // Loop through all segments to find the one closest to the user's click
                for (let i = 0; i < pts_w.length; i++) {
                    const current_p1 = pts_w[i];
                    const current_p2 = pts_w[(i + 1) % pts_w.length];
                    
                    if (!isClosed && i === pts_w.length - 1) continue;

                    const closest_pt_on_seg = closestPointOnLineWorld(sidePoint, current_p1, current_p2);
                    const dist_sq = (sidePoint.x - closest_pt_on_seg.x)**2 + (sidePoint.y - closest_pt_on_seg.y)**2;

                    if (dist_sq < min_dist_sq) {
                        min_dist_sq = dist_sq;
                        closest_seg_p1 = current_p1;
                        closest_seg_p2 = current_p2;
                    }
                }

                if (!closest_seg_p1) { logToHistory("Could not determine offset side."); cancelCommand(); return; }

                // Now, calculate the direction using the two points from the CLOSEST segment
                const cross_product = (closest_seg_p2.x - closest_seg_p1.x) * (sidePoint.y - closest_seg_p1.y) - (closest_seg_p2.y - closest_seg_p1.y) * (sidePoint.x - closest_seg_p1.x);
                const offset_angle_mod = cross_product > 0 ? -90 : 90;
                // --- END: MODIFIED LOGIC ---

                const parallel_segments = [];
                for (let i = 0; i < (isClosed ? pts_w.length : pts_w.length - 1); i++) {
                    const seg_p1 = pts_w[i];
                    const seg_p2 = pts_w[(i + 1) % pts_w.length];
                    const bearing = getBearing(seg_p1, seg_p2);
                    const normal_bearing = (bearing + offset_angle_mod + 360) % 360;
                    parallel_segments.push([
                        getDestinationPoint(seg_p1, cmd.data.distance, normal_bearing),
                        getDestinationPoint(seg_p2, cmd.data.distance, normal_bearing)
                    ]);
                }
                
                if (parallel_segments.length === 0) { logToHistory("Could not offset object."); cancelCommand(); return; }
                
                const new_pts_w = [];
                if (!isClosed) { new_pts_w.push(parallel_segments[0][0]); }

                for (let i = 0; i < (isClosed ? parallel_segments.length : parallel_segments.length - 1); i++) {
                    const seg1 = parallel_segments[i];
                    const seg2 = parallel_segments[(i + 1) % parallel_segments.length];
                    const intersection = intersectLineLineScreen(seg1[0], seg1[1], seg2[0], seg2[1], true);
                    new_pts_w.push(intersection || seg1[1]);
                }
                
                if (!isClosed) {
                    new_pts_w.push(parallel_segments[parallel_segments.length - 1][1]);
                } else if (new_pts_w.length > 0) {
                    new_pts_w.push(new_pts_w[0]);
                }

                newEnt = { layer: sourceEnt.layer, props: { ...sourceEnt.props } };
                if (sourceEnt.type === 'line') {
                    newEnt.type = 'line'; newEnt.a = new_pts_w[0]; newEnt.b = new_pts_w[1];
                } else {
                    newEnt.type = 'polyline'; newEnt.pts = new_pts_w; newEnt.closed = isClosed;
                }
            }

            if (newEnt) {
                pushEnt(newEnt);
            } else if (!sourceEnt.type.match(/^(circle|line|polyline)$/)) {
                logToHistory("Offset for this entity type is not yet implemented.");
            }

            logToHistory("Offset complete.");
            setPrompt("Select object to offset or press Enter to exit:");
            cmd.data.selectedEnt = null;
            cmd.step = 1;
            draw();
        }
    };
    
    cmd.processSubCommand = (input) => { if (input.trim() === '') completeCommand(); }
}


  function startFilletCommand() {
      const cmd = state.activeCommand;
      cmd.data = { radius: 0 };
      cmd.processInput = (input) => {
          if (cmd.step === 0) {
              const r = parseFloat(input);
              if (!isNaN(r) && r >= 0) {
                  cmd.data.radius = r; // Radius is now correctly in feet
                  logToHistory(`Fillet radius: ${r} ft`);
                  setPrompt("Select first object to fillet:");
                  cmd.step = 1;
              } else {
                  logToHistory("Invalid radius.");
                  cancelCommand();
              }
          }
      };
      cmd.execute = () => {
          const hit = hitTest(getPointInput(true));
          if (!hit || (hit.type !== 'line' && hit.type !== 'polyline')) return;
          if (cmd.step === 1) {
              cmd.data.ent1 = hit;
              setPrompt("Select second object to fillet:");
              cmd.step = 2;
          } else if (cmd.step === 2) {
              cmd.data.ent2 = hit;
              performFillet(cmd.data.ent1, cmd.data.ent2, cmd.data.radius, false);
              completeCommand();
          }
      };
  }

  function startChamferCommand() {
      const cmd = state.activeCommand;
      cmd.data = { d1: 0, d2: 0 };
      cmd.processInput = (input) => {
          const d = parseFloat(input);
          if (isNaN(d) || d < 0) { logToHistory("Invalid distance."); return; }

          if (cmd.step === 0) {
              cmd.data.d1 = d;
              logToHistory(`First distance: ${d} ft`);
              setPrompt("Specify second chamfer distance (feet):");
              cmd.step = 1;
          } else if (cmd.step === 1) {
              cmd.data.d2 = d;
              logToHistory(`Second distance: ${d} ft`);
              setPrompt("Select first line:");
              cmd.step = 2;
          }
      };
      cmd.execute = () => {
          const hit = hitTest(getPointInput(true));
          if (!hit || (hit.type !== 'line' && hit.type !== 'polyline')) return;
          if (cmd.step === 2) {
              cmd.data.ent1 = hit;
              setPrompt("Select second line:");
              cmd.step = 3;
          } else if (cmd.step === 3) {
              cmd.data.ent2 = hit;
              performFillet(cmd.data.ent1, cmd.data.ent2, {d1: cmd.data.d1, d2: cmd.data.d2}, true);
              completeCommand();
          }
      };
  }

  function performFillet(ent1, ent2, radiusOrDist_ft, isChamfer) {
      if (ent1.id === ent2.id) { logToHistory("Cannot fillet/chamfer an object with itself."); return; }
      
      const l1_w = ent1.type === 'line' ? {p1: ent1.a, p2: ent1.b} : {p1: ent1.pts[0], p2: ent1.pts[1]};
      const l2_w = ent2.type === 'line' ? {p1: ent2.a, p2: ent2.b} : {p1: ent2.pts[0], p2: ent2.pts[1]};

      const intersection_w = intersectLineLineScreen(l1_w.p1, l1_w.p2, l2_w.p1, l2_w.p2, true);
      if (!intersection_w) { logToHistory("Lines are parallel, cannot proceed."); return; }

      const v1 = { x: l1_w.p2.x - l1_w.p1.x, y: l1_w.p2.y - l1_w.p1.y }; let len = Math.hypot(v1.x, v1.y); v1.x /= len; v1.y /= len;
      const v2 = { x: l2_w.p2.x - l2_w.p1.x, y: l2_w.p2.y - l2_w.p1.y }; len = Math.hypot(v2.x, v2.y); v2.x /= len; v2.y /= len;

      if (Math.hypot(l1_w.p1.x - intersection_w.x, l1_w.p1.y - intersection_w.y) > Math.hypot(l1_w.p2.x - intersection_w.x, l1_w.p2.y - intersection_w.y)) { v1.x *= -1; v1.y *= -1; }
      if (Math.hypot(l2_w.p1.x - intersection_w.x, l2_w.p1.y - intersection_w.y) > Math.hypot(l2_w.p2.x - intersection_w.x, l2_w.p2.y - intersection_w.y)) { v2.x *= -1; v2.y *= -1; }

      if (isChamfer) {
          const { d1, d2 } = radiusOrDist_ft;
          const cp1 = { x: intersection_w.x + v1.x * d1, y: intersection_w.y + v1.y * d1 };
          const cp2 = { x: intersection_w.x + v2.x * d2, y: intersection_w.y + v2.y * d2 };
          
          pushEnt({ type: 'line', a: cp1, b: cp2, layer: ent1.layer, props: { ...ent1.props }});
          
          if (Math.hypot(l1_w.p1.x - intersection_w.x, l1_w.p1.y - intersection_w.y) > Math.hypot(l1_w.p2.x - intersection_w.x, l1_w.p2.y - intersection_w.y)) ent1.a = cp1; else ent1.b = cp1;
          if (Math.hypot(l2_w.p1.x - intersection_w.x, l2_w.p1.y - intersection_w.y) > Math.hypot(l2_w.p2.x - intersection_w.x, l2_w.p2.y - intersection_w.y)) ent2.a = cp2; else ent2.b = cp2;
          logToHistory("Chamfer complete.");

      } else { // Fillet
          const radius_ft = radiusOrDist_ft;
          const angle = Math.acos(v1.x * v2.x + v1.y * v2.y);
          if (Math.abs(angle) < 1e-6 || Math.abs(angle - Math.PI) < 1e-6) { logToHistory("Lines are parallel or collinear."); return; }
          const distToTangent = radius_ft / Math.tan(angle / 2);
          
          const t1 = { x: intersection_w.x + v1.x * distToTangent, y: intersection_w.y + v1.y * distToTangent };
          const t2 = { x: intersection_w.x + v2.x * distToTangent, y: intersection_w.y + v2.y * distToTangent };
          
          const bisector = { x: v1.x + v2.x, y: v1.y + v2.y }; len = Math.hypot(bisector.x, bisector.y); bisector.x /= len; bisector.y /= len;
          const distToCenter = radius_ft / Math.sin(angle/2);
          const center = { x: intersection_w.x + bisector.x * distToCenter, y: intersection_w.y + bisector.y * distToCenter };

          const crossProduct = v1.x * v2.y - v1.y * v2.x;
          const bisector_perp = {x: -bisector.y, y: bisector.x};
          const check_side_v = {x: v1.x-v2.x, y: v1.y-v2.y};
          if(bisector_perp.x*check_side_v.x + bisector_perp.y*check_side_v.y < 0 !== crossProduct > 0){
             center.x = intersection_w.x - bisector.x * distToCenter;
             center.y = intersection_w.y - bisector.y * distToCenter;
          }

          const startAngle = Math.atan2(t1.y - center.y, t1.x - center.x);
          const endAngle = Math.atan2(t2.y - center.y, t2.x - center.x);

          const arcPts_w = [];
          const segments = 20;
          let angleDiff = endAngle - startAngle;
          if (crossProduct > 0 && angleDiff < 0) angleDiff += Math.PI * 2;
          if (crossProduct < 0 && angleDiff > 0) angleDiff -= Math.PI * 2;
          
          for (let i = 0; i <= segments; i++) {
              const ang = startAngle + (angleDiff * i) / segments;
              arcPts_w.push({ x: center.x + radius_ft * Math.cos(ang), y: center.y + radius_ft * Math.sin(ang) });
          }
          
          pushEnt({ type: 'polyline', pts: arcPts_w, closed: false, layer: ent1.layer, props: { ...ent1.props }});
          
          if (Math.hypot(l1_w.p1.x - intersection_w.x, l1_w.p1.y - intersection_w.y) > Math.hypot(l1_w.p2.x - intersection_w.x, l1_w.p2.y - intersection_w.y)) ent1.a = t1; else ent1.b = t1;
          if (Math.hypot(l2_w.p1.x - intersection_w.x, l2_w.p1.y - intersection_w.y) > Math.hypot(l2_w.p2.x - intersection_w.x, l2_w.p2.y - intersection_w.y)) ent2.a = t2; else ent2.b = t2;
          logToHistory("Fillet complete.");
      }
      snapshot();
      draw();
  }

  function startMoveCommand(isCopy = false) {
      if (state.selection.length === 0) {
          logToHistory("No objects selected.");
          completeCommand();
          return;
      }
      const cmd = state.activeCommand;
      cmd.data.isCopy = isCopy;

      cmd.execute = () => {
          switch (cmd.step) {
              case 0:
                  const basePt = getPointInput();
                  if (basePt) {
                      cmd.data.base = basePt;
                      setPrompt("Specify second point:");
                      cmd.step++;
                  }
                  break;
              case 1:
                  const secondPt = getPointInput();
                  if (secondPt) {
                      const dx = secondPt.x - cmd.data.base.x;
                      const dy = secondPt.y - cmd.data.base.y;
                      const moveFunc = p => ({ x: p.x + dx, y: p.y + dy });

                      if (cmd.data.isCopy) {
                          for (const id of state.selection) {
                              const originalEnt = state.ents.find(e => e.id === id);
                              if (!originalEnt) continue;
                              const newEnt = JSON.parse(JSON.stringify(originalEnt));
                              delete newEnt.id; // ensure pushEnt assigns a new one
                              transformPoints(newEnt, moveFunc);
                              pushEnt(newEnt);
                          }
                          logToHistory(`${state.selection.length} object(s) copied.`);
                      } else {
                          for (const id of state.selection) {
                              const ent = state.ents.find(e => e.id === id);
                              if (ent) transformPoints(ent, moveFunc);
                          }
                          logToHistory(`${state.selection.length} object(s) moved.`);
                      }
                      snapshot();
                      completeCommand();
                  }
                  break;
          }
      };
  }

  function startCopyCommand() {
      startMoveCommand(true);
  }

  function startPasteCommand() {
      if (state.clipboard.data.length === 0) {
          logToHistory("Clipboard is empty.");
          completeCommand();
          return;
      }
      const cmd = state.activeCommand;
      cmd.execute = () => {
          const insertionPoint = getPointInput();
          if (insertionPoint) {
              const { data: clipboardEnts, basePoint } = state.clipboard;
              const dx = insertionPoint.x - basePoint.x;
              const dy = insertionPoint.y - basePoint.y;
              const moveFunc = p => ({ x: p.x + dx, y: p.y + dy });
              const newSelection = [];

              for (const ent of clipboardEnts) {
                  const newEnt = JSON.parse(JSON.stringify(ent));
                  delete newEnt.id;
                  transformPoints(newEnt, moveFunc);
                  const pushed = pushEnt(newEnt);
                  newSelection.push(pushed.id);
              }

              state.selection = newSelection;
              logToHistory(`${clipboardEnts.length} object(s) pasted.`);
              snapshot();
              updatePropertiesPanel();
              completeCommand();
          }
      };
  }

  function startTransformCommand(type) {
      if (state.selection.length === 0) {
          logToHistory("No objects selected.");
          completeCommand();
          return;
      }
      const cmd = state.activeCommand;
      cmd.data.type = type;

      cmd.execute = () => {
          switch (cmd.step) {
              case 0:
                  const basePt = getPointInput();
                  if (basePt) {
                      cmd.data.base = basePt;
                      const promptText = type === 'rotate' ? "Specify reference point for angle:" : "Specify reference point for scale:";
                      setPrompt(promptText);
                      cmd.step++;
                  }
                  break;
              case 1:
                  const refPt = getPointInput();
                  if (refPt) {
                      cmd.data.ref = refPt;
                       const promptText = type === 'rotate' ? "Specify new angle:" : "Specify new distance:";
                      setPrompt(promptText);
                      cmd.step++;
                  }
                  break;
              case 2:
                  const destPt = getPointInput();
                  if (destPt) {
                      const base_s = worldToScreen(cmd.data.base);
                      const ref_s = worldToScreen(cmd.data.ref);
                      const dest_s = worldToScreen(destPt);

                      const v_ref = { x: ref_s.x - base_s.x, y: ref_s.y - base_s.y };
                      const v_dest = { x: dest_s.x - base_s.x, y: dest_s.y - base_s.y };
                      const len_ref = Math.hypot(v_ref.x, v_ref.y);
                      const len_dest = Math.hypot(v_dest.x, v_dest.y);

                      if (len_ref < 1e-6) {
                          logToHistory("Reference and base points are too close.");
                          cancelCommand();
                          return;
                      }

                      const scaleFactor = (cmd.data.type === 'scale') ? (len_dest / len_ref) : 1.0;
                      const angleRad = (cmd.data.type === 'rotate') ? (Math.atan2(v_dest.y, v_dest.x) - Math.atan2(v_ref.y, v_ref.x)) : 0.0;
                      const cosA = Math.cos(angleRad);
                      const sinA = Math.sin(angleRad);

                      const transformFunc = (p_world) => {
                          const p_s = worldToScreen(p_world);
                          const dx = p_s.x - base_s.x;
                          const dy = p_s.y - base_s.y;
                          const scaled_dx = dx * scaleFactor;
                          const scaled_dy = dy * scaleFactor;
                          const new_dx = scaled_dx * cosA - scaled_dy * sinA;
                          const new_dy = scaled_dx * sinA + scaled_dy * cosA;
                          return screenToWorld({ x: base_s.x + new_dx, y: base_s.y + new_dy });
                      };

                      for (const id of state.selection) {
                          const ent = state.ents.find(e => e.id === id);
                          if (!ent) continue;
                          transformPoints(ent, transformFunc);
                          if (ent.type === 'circle' && cmd.data.type === 'scale') {
                              ent.r *= scaleFactor;
                          }
                          if ( (ent.type === 'text' || ent.type === 'mtext') && cmd.data.type === 'rotate') {
                             ent.rotation = (ent.rotation || 0) + (angleRad * 180 / Math.PI);
                          }
                      }

                      snapshot();
                      logToHistory(`${state.selection.length} object(s) transformed.`);
                      completeCommand();
                  }
                  break;
          }
      };
  }

  function startRotateCommand() { startTransformCommand('rotate'); }
  function startScaleCommand() { startTransformCommand('scale'); }
  
  function startDistanceCommand() {
      const cmd = state.activeCommand;
      cmd.execute = () => {
          switch (cmd.step) {
              case 0:
                  const p1 = getPointInput();
                  if (p1) {
                      cmd.data.start = p1;
                      setPrompt("Specify second point:");
                      cmd.step++;
                  }
                  break;
              case 1:
                  const p2 = getPointInput();
                  if (p2) {
                      const dx = p2.x - cmd.data.start.x;
                      const dy = p2.y - cmd.data.start.y;
                      const dist = Math.hypot(dx, dy);
                      
                      logToHistory(`Distance: ${dist.toFixed(4)} ft`);
                      logToHistory(`Delta X: ${dx.toFixed(4)} ft, Delta Y: ${dy.toFixed(4)} ft`);
                      
                      completeCommand();
                  }
                  break;
          }
      };
  }
  
    // =======================================================
    // SECTION: NEWLY ADDED & FIXED COMMANDS
    // =======================================================

    function startMirrorCommand() {
        if (state.selection.length === 0) { logToHistory("No objects selected."); completeCommand(); return; }
        const cmd = state.activeCommand;
        cmd.execute = () => {
            switch (cmd.step) {
                case 0:
                    const p1 = getPointInput();
                    if (p1) { cmd.data.p1 = p1; setPrompt("Specify second point of mirror line:"); cmd.step++; }
                    break;
                case 1:
                    const p2 = getPointInput();
                    if (p2) {
                        const p1_s = worldToScreen(cmd.data.p1);
                        const p2_s = worldToScreen(p2);

                        const transformFunc = (p_world) => {
                            const p_s = worldToScreen(p_world);
                            const reflected_s = reflectPointScreen(p_s, p1_s, p2_s);
                            return screenToWorld(reflected_s);
                        };

                        state.selection.forEach(id => {
                            const originalEnt = state.ents.find(e => e.id === id);
                            if (!originalEnt) return;
                            const newEnt = JSON.parse(JSON.stringify(originalEnt));
                            delete newEnt.id;
                            transformPoints(newEnt, transformFunc);
                            pushEnt(newEnt);
                        });
                        logToHistory(`${state.selection.length} object(s) mirrored.`);
                        snapshot();
                        completeCommand();
                    }
                    break;
            }
        };
    }

    function startStretchCommand() {
        const cmd = state.activeCommand;
        cmd.execute = () => {
            if (cmd.step === 0) {
                logToHistory("Use a crossing window (right to left) to select vertices to stretch.");
                state.selectionBox = { start: null, end: null, type: 'crossing', isForStretch: true };
                setPrompt("Specify first corner:");
                cmd.step = 1;
            } else if (cmd.step === 2) { // Base point
                const basePt = getPointInput();
                if (basePt) {
                    cmd.data.base = basePt;
                    setPrompt("Specify second point:");
                    cmd.step++;
                }
            } else if (cmd.step === 3) { // Displacement point
                const secondPt = getPointInput();
                if (secondPt) {
                    const dx = secondPt.x - cmd.data.base.x;
                    const dy = secondPt.y - cmd.data.base.y;

                    for (const { ent, vertices } of cmd.data.vertsToStretch) {
                        const moveFunc = p => ({ x: p.x + dx, y: p.y + dy });
                        if (ent.type === 'line') {
                            if(vertices.includes(0)) ent.a = moveFunc(ent.a);
                            if(vertices.includes(1)) ent.b = moveFunc(ent.b);
                        } else if (ent.type === 'polyline') {
                            ent.pts.forEach((pt, index) => {
                                if (vertices.includes(index)) ent.pts[index] = moveFunc(pt);
                            });
                        }
                    }
                    snapshot();
                    completeCommand();
                }
            }
        };
    }

    function startExplodeCommand() {
        if (state.selection.length === 0) { logToHistory("No objects selected."); completeCommand(); return; }
        let explodedCount = 0;
        const toDelete = [];
        const newLines = [];
        state.selection.forEach(id => {
            const ent = state.ents.find(e => e.id === id);
            if (ent && ent.type === 'polyline' && ent.pts.length > 1) {
                for (let i = 0; i < ent.pts.length - 1; i++) {
                    newLines.push({ type: 'line', a: ent.pts[i], b: ent.pts[i + 1], layer: ent.layer, props: { ...ent.props } });
                }
                toDelete.push(id);
                explodedCount++;
            }
        });

        if (explodedCount > 0) {
            state.ents = state.ents.filter(e => !toDelete.includes(e.id));
            newLines.forEach(l => pushEnt(l));
            snapshot();
            logToHistory(`${explodedCount} object(s) exploded.`);
        } else {
            logToHistory("No polylines found in selection to explode.");
        }
        completeCommand();
    }

    function startMatchpropCommand() {
        const cmd = state.activeCommand;
        cmd.execute = () => {
            switch (cmd.step) {
                case 0:
                    const sourceHit = hitTest(getPointInput(true));
                    if (sourceHit) {
                        cmd.data.sourceLayer = sourceHit.layer;
                        cmd.data.sourceProps = { ...sourceHit.props };
                        logToHistory("Source object selected.");
                        setPrompt("Select destination object(s) or press Enter to exit:");
                        cmd.step++;
                    }
                    break;
                case 1:
                    const destHit = hitTest(getPointInput(true));
                    if (destHit) {
                        const ent = state.ents.find(e => e.id === destHit.id);
                        if (ent) {
                            ent.layer = cmd.data.sourceLayer;
                            ent.props = { ...ent.props, ...cmd.data.sourceProps };
                            logToHistory("Properties matched.");
                            draw();
                        }
                    }
                    break;
            }
        };
        cmd.processSubCommand = (input) => {
            if (input.trim() === '') completeCommand();
        }
    }
    
    function startJoinCommand() {
      if (state.selection.length > 0) {
          performJoin(state.selection);
          completeCommand();
      } else {
          const cmd = state.activeCommand;
          cmd.step = 1;
          setPrompt("Select objects to join:");
          
          cmd.processSubCommand = (input) => {
              if (input.trim() === '' && state.selection.length > 0) {
                  performJoin(state.selection);
                  completeCommand();
              } else {
                  logToHistory("No objects selected.");
                  cancelCommand();
              }
          };
      }
    }

    function performJoin(selectionIds) {
      const selectedEnts = selectionIds.map(id => state.ents.find(e => e.id === id)).filter(Boolean);
      const segments = [];
      const originalEntIds = [];

      selectedEnts.forEach(ent => {
          if (ent.type === 'line') {
              segments.push([ent.a, ent.b]);
              originalEntIds.push(ent.id);
          } else if (ent.type === 'polyline') {
              for (let i = 0; i < ent.pts.length - 1; i++) {
                  segments.push([ent.pts[i], ent.pts[i+1]]);
              }
              originalEntIds.push(ent.id);
          }
      });

      if (segments.length < 2) {
          logToHistory("Need at least two joinable objects.");
          return;
      }

      const chains = [];
      while (segments.length > 0) {
          let currentChain = segments.shift();

          let foundMatch = true;
          while (foundMatch) {
              foundMatch = false;
              for (let i = segments.length - 1; i >= 0; i--) {
                  const segment = segments[i];
                  const chainStart = currentChain[0];
                  const chainEnd = currentChain[currentChain.length - 1];

                  if (pointsAreEqual(chainEnd, segment[0])) {
                      currentChain.push(segment[1]);
                      segments.splice(i, 1);
                      foundMatch = true;
                  } else if (pointsAreEqual(chainEnd, segment[1])) {
                      currentChain.push(segment[0]);
                      segments.splice(i, 1);
                      foundMatch = true;
                  } else if (pointsAreEqual(chainStart, segment[1])) {
                      currentChain.unshift(segment[0]);
                      segments.splice(i, 1);
                      foundMatch = true;
                  } else if (pointsAreEqual(chainStart, segment[0])) {
                      currentChain.unshift(segment[1]);
                      segments.splice(i, 1);
                      foundMatch = true;
                  }
              }
          }
          chains.push(currentChain);
      }

      state.ents = state.ents.filter(e => !originalEntIds.includes(e.id));

      let joinCount = 0;
      chains.forEach(chain => {
          const firstEnt = selectedEnts[0];
          if (chain.length > 0) { 
              const isClosed = pointsAreEqual(chain[0], chain[chain.length - 1]);
              
              pushEnt({ 
                  type: 'polyline', 
                  pts: chain, 
                  closed: isClosed, 
                  layer: firstEnt.layer, 
                  props: firstEnt.props 
              });
              
              if (chains.length < originalEntIds.length) joinCount++;
          }
      });
      
      logToHistory(joinCount > 0 ? `${originalEntIds.length} objects joined into ${chains.length} polyline(s).` : "No objects could be joined.");
      snapshot();
      clearSelection();
      draw();
    }

    function startBreakCommand() {
        const cmd = state.activeCommand;
        cmd.execute = () => {
            if (cmd.step === 0) {
                const hit = hitTest(getPointInput(true));
                if (hit && hit.type === 'line') {
                    cmd.data.ent = hit;
                    const breakPt = getPointInput();
                    const line = cmd.data.ent;
                    const p1 = line.a;
                    const p2 = line.b;

                    state.ents = state.ents.filter(e => e.id !== line.id);
                    pushEnt({ type: 'line', a: p1, b: breakPt, layer: line.layer, props: { ...line.props } });
                    pushEnt({ type: 'line', a: breakPt, b: p2, layer: line.layer, props: { ...line.props } });

                    logToHistory("Line broken.");
                    snapshot();
                    completeCommand();
                } else if (hit) {
                    logToHistory("Break command currently only supports lines.");
                    cancelCommand();
                }
            }
        };
    }

    function startTrimCommand() {
        logToHistory("Trim command is not implemented in this version.");
        completeCommand();
    }
    function startExtendCommand() {
        logToHistory("Extend command is not implemented in this version.");
        completeCommand();
    }
    function startLengthenCommand() {
        logToHistory("Lengthen command is not implemented in this version.");
        completeCommand();
    }

    function startArrayCommand() {
        if (state.selection.length === 0) { logToHistory("No objects selected."); completeCommand(); return; }
        const cmd = state.activeCommand;
        cmd.processInput = (input) => {
            const num = parseFloat(input);
            if (isNaN(num)) { logToHistory("Invalid number."); return; }
            switch (cmd.step) {
                case 0:
                    cmd.data.rows = parseInt(num);
                    setPrompt("Enter number of columns:");
                    cmd.step++;
                    break;
                case 1:
                    cmd.data.cols = parseInt(num);
                    setPrompt("Specify distance between rows (feet):");
                    cmd.step++;
                    break;
                case 2:
                    cmd.data.rowSpacing = num;
                    setPrompt("Specify distance between columns (feet):");
                    cmd.step++;
                    break;
                case 3:
                    cmd.data.colSpacing = num;
                    performArray(cmd.data);
                    completeCommand();
                    break;
            }
        };
    }
    function startZoomCommand() {
      const cmd = state.activeCommand;
      cmd.data = {}; // Reset data for this command instance

      cmd.processInput = (input) => {
          const option = input.trim().toLowerCase();
          switch (option) {
              case 'e': case 'extents': zoomExtents(); completeCommand(); break;
              case 'w': case 'window':
                  logToHistory("Zoom Window activated.");
                  setPrompt("Specify first corner:");
                  cmd.step = 1;
                  break;
              case 'p': case 'previous': zoomPrevious(); completeCommand(); break;
              case 'o': case 'object':
                   if (state.selection.length === 0) {
                       logToHistory("No objects selected. Please select objects before using Zoom Object.");
                       completeCommand();
                       return;
                   }
                   zoomExtents(state.selection);
                   completeCommand();
                   break;
              default: logToHistory(`Unknown zoom option "${input}".`); cancelCommand(); break;
          }
      };

      cmd.execute = () => {
          if (cmd.step === 1) { // First corner for Zoom Window
              const p1 = getPointInput();
              if (p1) { cmd.data.p1 = p1; setPrompt("Specify opposite corner:"); cmd.step = 2; }
          } else if (cmd.step === 2) { // Second corner for Zoom Window
              const p2 = getPointInput();
              if (p2) {
                  const dLat1 = cmd.data.p1.y / feetPerDegree.lat;
                  const dLng1 = cmd.data.p1.x / feetPerDegree.lng;
                  const p1_latlng = L.latLng(cadOrigin.lat + dLat1, cadOrigin.lng + dLng1);

                  const dLat2 = p2.y / feetPerDegree.lat;
                  const dLng2 = p2.x / feetPerDegree.lng;
                  const p2_latlng = L.latLng(cadOrigin.lat + dLat2, cadOrigin.lng + dLng2);
                  
                  const bounds = L.latLngBounds(p1_latlng, p2_latlng);

                  if (bounds.isValid()) {
                      saveCurrentView();
                      state.isZoomingProgrammatically = true;
                      leafletMap.fitBounds(bounds);
                  }
                  completeCommand();
              }
          }
      };
  }
  function zoomExtents(idList = null) {
      const targetEnts = idList ? idList.map(id => state.ents.find(e => e.id === id)).filter(Boolean) : state.ents;
      if (targetEnts.length === 0) { logToHistory("No objects to zoom to."); return; }
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      targetEnts.forEach(ent => {
          const grips = getGripsForEnt(ent);
          grips.forEach(pt => { // pt is in feet
              minX = Math.min(minX, pt.x); maxX = Math.max(maxX, pt.x);
              minY = Math.min(minY, pt.y); maxY = Math.max(maxY, pt.y);
          });
      });
      
      const sw_dLat = minY / feetPerDegree.lat; const sw_dLng = minX / feetPerDegree.lng;
      const ne_dLat = maxY / feetPerDegree.lat; const ne_dLng = maxX / feetPerDegree.lng;
      
      const sw_latlng = L.latLng(cadOrigin.lat + sw_dLat, cadOrigin.lng + sw_dLng);
      const ne_latlng = L.latLng(cadOrigin.lat + ne_dLat, cadOrigin.lng + ne_dLng);
      const bounds = L.latLngBounds(sw_latlng, ne_latlng);

      if (bounds.isValid()) {
          saveCurrentView();
          state.isZoomingProgrammatically = true;
          leafletMap.fitBounds(bounds, { padding: [20, 20] });
      }
  }

  function zoomPrevious() {
      if (state.viewHistory.length < 1) { logToHistory("No previous view to restore."); return; }
      const previousView = state.viewHistory.pop();
      state.isZoomingProgrammatically = true;
      leafletMap.setView(previousView.center, previousView.zoom);
      logToHistory("Zoomed to previous view.");
  }

  function saveCurrentView() {
      if (state.isZoomingProgrammatically) {
        state.isZoomingProgrammatically = false;
        return;
      }
      const currentView = { center: leafletMap.getCenter(), zoom: leafletMap.getZoom() };
      const lastView = state.viewHistory[state.viewHistory.length - 1];
      if (!lastView || !lastView.center.equals(currentView.center) || lastView.zoom !== currentView.zoom) {
          state.viewHistory.push(currentView);
          if (state.viewHistory.length > 20) { state.viewHistory.shift(); }
      }
  }

    function performArray(data) {
        const { rows, cols, rowSpacing, colSpacing } = data;
        if (rows < 1 || cols < 1) { logToHistory("Rows and columns must be 1 or greater."); return; }
        const originalEnts = state.selection.map(id => state.ents.find(e => e.id === id)).filter(Boolean);

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (r === 0 && c === 0) continue;
                originalEnts.forEach(originalEnt => {
                    const newEnt = JSON.parse(JSON.stringify(originalEnt));
                    delete newEnt.id;
                    const transformFunc = p => {
                        let tempPt = getDestinationPoint(p, r * rowSpacing, 0); // North (Y) for rows
                        tempPt = getDestinationPoint(tempPt, c * colSpacing, 90); // East (X) for columns
                        return tempPt;
                    };
                    transformPoints(newEnt, transformFunc);
                    pushEnt(newEnt);
                });
            }
        }
        snapshot();
        logToHistory(`Array created (${rows}x${cols}).`);
    }

  function getPointInput(isSelection=false) { if(state.snapPoint && !isSelection) return state.snapPoint; return {x: state.mouse.worldX, y: state.mouse.worldY }; }


  // =======================================================
  // SECTION: MOUSE AND KEYBOARD INPUT HANDLING
  // =======================================================

  function bindEvents() {
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('dblclick', onDblClick);
    canvas.addEventListener('wheel', onMouseWheel, {passive:false});
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('resize', resize);
    window.addEventListener('click', () => hideContextMenu()); // Hide context menu on any click

    document.getElementById('gridToggle').onclick = () => toggleState('grid');
    document.getElementById('orthoToggle').onclick = () => toggleState('ortho');
    document.getElementById('osnapToggle').onclick = () => toggleState('osnap');
    document.getElementById('toolbar').addEventListener('click', e => { if(e.target.dataset.command) { runCommand(e.target.dataset.command); } });

    let cmdHistoryIndex = -1;
    cmdInput.addEventListener('keydown', (e) => {
        e.stopPropagation();
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            const cmdStr = cmdInput.value;
            cmdInput.value = '';
            cmdHistoryIndex = -1;

            if (state.activeCommand) {
                if (typeof state.activeCommand.processInput === 'function') {
                    state.activeCommand.processInput(cmdStr);
                    return;
                }
                if (typeof state.activeCommand.processSubCommand === 'function') {
                    state.activeCommand.processSubCommand(cmdStr);
                    return;
                }
            }
            runCommand(cmdStr);
        } else if (e.key === 'Escape') {
            cancelCommand();
        } else if (e.key === 'ArrowUp') {
            if(state.commandHistory.length > 0) {
                cmdHistoryIndex = Math.min(cmdHistoryIndex + 1, state.commandHistory.length - 1);
                cmdInput.value = state.commandHistory[state.commandHistory.length - 1 - cmdHistoryIndex];
            }
        } else if (e.key === 'ArrowDown') {
            if(cmdHistoryIndex > 0) {
                cmdHistoryIndex--;
                cmdInput.value = state.commandHistory[state.commandHistory.length - 1 - cmdHistoryIndex];
            } else {
                cmdHistoryIndex = -1; cmdInput.value = '';
            }
        }
    });

    document.getElementById('undoBtn').onclick = undo;
    document.getElementById('redoBtn').onclick = redo;
    document.getElementById('addLayerBtn').onclick = addLayer;
    document.getElementById('toggleMapBtn').onclick = toggleMap;

    document.getElementById('searchCoordsBtn').onclick = searchLocation;
    document.getElementById('searchCoordsInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            searchLocation();
        }
    });

    document.getElementById('exportKmzBtn').onclick = () => exportToKmz(state.ents);
    document.getElementById('exportDxfBtn').onclick = () => exportToDxf(state.ents);
    document.getElementById('saveBtn').onclick = saveDrawing;
    document.getElementById('openBtn').onclick = () => fileInput.click();
    fileInput.addEventListener('change', openDrawing);
    layersDiv.addEventListener('input', onLayerChange);

    propertiesPanel.addEventListener('input', (e) => {
        const targetId = e.target.id;
        if (!targetId.startsWith('prop')) return;
        
        if (state.selection.length === 1) {
            const ent = state.ents.find(e => e.id === state.selection[0]);
            if (ent && (ent.type === 'text' || ent.type === 'mtext')) {
                updateSelectedText(targetId, e.target.value);
                return;
            }
        }
        
        const prop = targetId.replace('prop', '').toLowerCase();
        const value = e.target.value;

        if (state.selection.length > 0) {
            updateSelectedEnts(prop, value);
        } else {
            const isNumeric = ['linetypescale', 'transparency', 'thickness'].includes(prop);
            
            if (prop === 'layer') {
                state.currentLayer = value;
            } else {
                state.currentProperties[prop] = isNumeric ? parseFloat(value) : value;
            }
            updatePropertiesPanel();
        }
    });
      
    // --- Modal Event Handlers ---
    document.getElementById('startVectorizeBtn').onclick = () => {
        document.getElementById('vectorizeModal').style.display = 'none';
        performMapVectorization();
    };
    document.getElementById('cancelVectorizeBtn').onclick = () => {
        document.getElementById('vectorizeModal').style.display = 'none';
        logToHistory("Map to CAD cancelled.");
        cancelCommand();
    };
    document.getElementById('cannyThreshold1').oninput = e => { document.getElementById('cannyThreshold1Value').textContent = e.target.value; };
    document.getElementById('cannyThreshold2').oninput = e => { document.getElementById('cannyThreshold2Value').textContent = e.target.value; };
    document.getElementById('epsilon').oninput = e => { document.getElementById('epsilonValue').textContent = e.target.value; };

    // Mtext Modal Handlers
    document.getElementById('saveMtextBtn').onclick = () => {
        const modal = document.getElementById('mtextModal');
        const text = document.getElementById('mtextInput').value;
        modal.style.display = 'none';

        if (state.activeCommand && state.activeCommand.name === 'mtext') {
            const { p1, p2 } = state.activeCommand.data;
            const rotation = getBearing(p1, p2);
            const width_ft = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const text_height_ft = 10.0; // Default height in feet

            pushEnt({
                type: 'mtext',
                insertionPoint: p1,
                width: width_ft,
                height: text_height_ft,
                rotation: rotation,
                textString: text,
                layer: state.currentLayer,
                props: curProps()
            });
            completeCommand();
        } else if (state.editingEnt) { // Handle editing
            state.editingEnt.textString = text;
            state.editingEnt = null;
            snapshot();
            draw();
        }
    };
    document.getElementById('cancelMtextBtn').onclick = () => {
        document.getElementById('mtextModal').style.display = 'none';
        if(state.activeCommand && state.activeCommand.name === 'mtext') cancelCommand();
        state.editingEnt = null;
    };
    leafletMap.on('zoomend', saveCurrentView);
    leafletMap.on('moveend', saveCurrentView);

    // Download Manager Handlers
    document.getElementById('downloadManagerBtn').onclick = () => {
        document.getElementById('downloadManagerModal').style.display = 'flex';
    };
    document.getElementById('cancelDownloadBtn').onclick = () => {
        document.getElementById('downloadManagerModal').style.display = 'none';
    };
    document.getElementById('filterDownloadBtn').onclick = startDownloadManagerExport;

  }

  async function searchLocation() {
      const query = document.getElementById('searchCoordsInput').value;
      if (!query.trim()) {
          logToHistory("Search query is empty.");
          return;
      }

      logToHistory(`Searching for "${query}"...`);
      const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`;

      try {
          const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
          if (!response.ok) {
              throw new Error(`Network response was not ok: ${response.statusText}`);
          }
          const data = await response.json();

          if (data && data.length > 0) {
              const result = data[0];
              const lat = parseFloat(result.lat);
              const lon = parseFloat(result.lon);

              logToHistory(`Location found: ${result.display_name}`);
              leafletMap.setView([lat, lon], 17);
              // CRITICAL: Reset the CAD origin when moving to a new location
              setCadOrigin();
              // Optional: clear existing drawing or ask user
              // state.ents = [];
              // draw();
              logToHistory("CAD origin reset to new location.");
          } else {
              logToHistory(`Could not find a location for "${query}".`);
          }
      } catch (error) {
          logToHistory(`Error during search: ${error.message}`);
          console.error("Geocoding search failed:", error);
      }
  }

  function onDblClick(e) {
    if (state.activeCommand) return;
    const worldPt = screenToWorld({x: state.mouse.x, y: state.mouse.y});
    const hit = hitTest(worldPt);

    if (hit && (hit.type === 'text' || hit.type === 'mtext')) {
        clearSelection();
        toggleSelect(hit.id, true);
        if (hit.type === 'mtext') {
            state.editingEnt = state.ents.find(ent => ent.id === hit.id);
            const modal = document.getElementById('mtextModal');
            document.getElementById('mtextInput').value = state.editingEnt.textString;
            modal.style.display = 'flex';
        }
    }
  }

  function onMouseDown(e) {
      state.mouse.isDown = true;
      state.mouse.lastX = e.clientX;
      state.mouse.lastY = e.clientY;

      const clickTime = Date.now();
      const isDoubleClick = (clickTime - state.mouse.lastClickTime) < 300;
      state.mouse.lastClickTime = clickTime;
      if (isDoubleClick) return;

      if (e.button === 1) { 
        state.mouse.isPanning = true; 
        leafletMap.dragging.disable(); 
        canvas.style.cursor = 'none';
        return; 
      }
      if (e.button === 0) {
          if (state.activeGrip) { finalizeGripEdit(); return; }

          if (state.activeCommand) {
              if (state.activeCommand.name === 'stretch' && state.activeCommand.step === 1) {
                  state.selectionBox.start = { x: state.mouse.x, y: state.mouse.y };
              } else {
                  state.activeCommand.execute();
              }
              return;
          }

          if (state.selection.length > 0) {
              const gripHit = gripHitTest(getPointInput(true));
              if (gripHit) {
                  startGripEdit(gripHit);
                  return;
              }
          }

          const hit = hitTest(getPointInput(true));
          if (hit) {
              if (!e.shiftKey) clearSelection();
              toggleSelect(hit.id, !isSelected(hit.id));
              draw();
          } else {
              if (!e.shiftKey) clearSelection();
              state.selectionBox = {
                  start: { x: state.mouse.x, y: state.mouse.y },
                  end: { x: state.mouse.x, y: state.mouse.y },
                  type: 'window'
              };
          }
      }
  }

  function onMouseUp(e) {
    if (e.button === 2) { // Right-click
        if(state.activeCommand) {
            if(state.activeCommand.name === 'polyline' && state.activeCommand.data.points.length > 1) {
                pushEnt({type:'polyline', pts: state.activeCommand.data.points, closed: false, layer: state.currentLayer, props: curProps()});
            }
            completeCommand();
        } else {
            const gripHit = gripHitTest(getPointInput(true));
            if(gripHit) {
                showContextMenu(e.clientX, e.clientY, gripHit);
            } else {
                if (state.lastCommand) runCommand(state.lastCommand.name);
            }
        }
        return;
    }

    if (state.selectionBox) {
        if (state.activeCommand && state.activeCommand.name === 'stretch') {
             finalizeStretchSelection();
        } else {
            const dx = Math.abs(state.selectionBox.start.x - state.selectionBox.end.x);
            const dy = Math.abs(state.selectionBox.start.y - state.selectionBox.end.y);
            if (dx > 4 || dy > 4) {
                finalizeSelectionBox();
            } else {
                 updatePropertiesPanel();
            }
        }
        state.selectionBox = null;
        draw();
    }

    state.mouse.isDown = false;
    state.mouse.isPanning = false;
    leafletMap.dragging.enable();
    canvas.style.cursor = 'none';
  }

  function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    state.mouse.x = e.clientX - rect.left;
    state.mouse.y = e.clientY - rect.top;

    if (state.mouse.isPanning) {
        const dx = e.clientX - state.mouse.lastX;
        const dy = e.clientY - state.mouse.lastY;
        leafletMap.panBy([ -dx, -dy ], { animate: false });
        state.mouse.lastX = e.clientX;
        state.mouse.lastY = e.clientY;
        draw();
        return;
    }

    if (state.mouse.isDown && state.selectionBox) {
        state.selectionBox.end = { x: state.mouse.x, y: state.mouse.y };
        if (!state.selectionBox.isForStretch) {
            state.selectionBox.type = (state.selectionBox.end.x > state.selectionBox.start.x) ? 'window' : 'crossing';
        }
        draw();
        return;
    }

    const worldPt = screenToWorld(state.mouse);
    state.mouse.worldX = worldPt.x; state.mouse.worldY = worldPt.y;
    evaluateSnaps();

    if (state.activeGrip) {
        const ent = state.ents.find(e => e.id === state.activeGrip.entId);
        if (!ent) { cancelGripEdit(); return; }
        let newPt = getPointInput();
        if (state.ortho) {
            const originalPt = getGripsForEnt(state.activeGrip.originalEnt)[state.activeGrip.ptIndex];
            newPt = orthoPoint(originalPt, newPt);
        }
        updateEntityWithNewGrip(ent, state.activeGrip.ptIndex, newPt);
        cursorPosEl.textContent = `X: ${newPt.x.toFixed(2)} ft, Y: ${newPt.y.toFixed(2)} ft`;
        updateTooltipPosition(e);
        draw();
        return;
    }

    if (state.ortho && state.activeCommand && (state.activeCommand.name === 'line' || state.activeCommand.name === 'polyline' || state.activeCommand.name === 'rect') && (state.activeCommand.data.start || state.activeCommand.data.points?.length > 0)) {
        const lastPt = state.activeCommand.name === 'polyline' ? state.activeCommand.data.points.slice(-1)[0] : state.activeCommand.data.start;
        if(lastPt) {
            const orthoPt = orthoPoint(lastPt, getPointInput());
            state.mouse.worldX = orthoPt.x; state.mouse.worldY = orthoPt.y;
        }
    }

    cursorPosEl.textContent = `X: ${state.mouse.worldX.toFixed(2)} ft, Y: ${state.mouse.worldY.toFixed(2)} ft`;
    updateTooltipPosition(e);
    draw();
  }

  function onMouseWheel(e) {
      e.preventDefault();
      const latlng = leafletMap.containerPointToLatLng([state.mouse.x, state.mouse.y]);
      const newZoom = leafletMap.getZoom() + (e.deltaY < 0 ? 1 : -1);
      if (newZoom >= leafletMap.getMinZoom() && newZoom <= leafletMap.getMaxZoom()) {
          leafletMap.setZoomAround(latlng, newZoom, { animate: false });
      }
  }

  function onKeyDown(e) {
  const activeEl = document.activeElement;
  if (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA') return;
    if (e.key === 'Escape') {
      hideContextMenu();
      if (state.activeGrip) { cancelGripEdit(); }
      else { cancelCommand(); }
    }
    if (e.key === 'F3') { e.preventDefault(); toggleState('osnap'); }
    if (e.key === 'F7') { e.preventDefault(); toggleState('grid'); }
    if (e.key === 'F8') { e.preventDefault(); toggleState('ortho'); }
    if(e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
    if(e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
    if(e.ctrlKey && e.key === 'c') { e.preventDefault(); copyToClipboard(); }
    if(e.ctrlKey && e.key === 'v') { e.preventDefault(); runCommand('paste'); }

    if(document.activeElement !== cmdInput) {
        if(e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) { cmdInput.focus(); cmdInput.value += e.key; e.preventDefault();
        } else if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); runCommand(null); }
    }
  }

  // =======================================================
  // SECTION: DRAWING, SNAPPING & HIT-TESTING
  // =======================================================

  function draw() {
    if (!leafletMap) return;
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    if(state.grid && mapState === 0) drawGrid();
    for(const e of state.ents){
        const layer = state.layers.find(l=>l.name===e.layer) || {color:'#e6e9ef', visible:true};
        if(!layer.visible) continue;
        
        const effectiveProps = {
            color: (e.props && e.props.color && e.props.color !== 'ByLayer') ? e.props.color : layer.color,
            linetype: (e.props && e.props.linetype && e.props.linetype !== 'ByLayer') ? e.props.linetype : 'Continuous',
            lineweight: (e.props && e.props.lineweight && e.props.lineweight !== 'ByLayer') ? e.props.lineweight : 'Default',
            linetypeScale: (e.props && e.props.linetypeScale) ? e.props.linetypeScale : 1.0,
            transparency: (e.props && e.props.transparency) ? e.props.transparency : 0,
        };
        
        drawEnt(e, effectiveProps, isSelected(e.id));
    }

    drawSelectionGrips();
    drawTemporaryGeometry();
    drawSelectionBox();
    if(state.snapPoint) drawSnapMarker();
    
    drawCrosshairCursor();

    ctx.setLineDash([]);
    ctx.globalAlpha = 1.0;
  }

  function drawEnt(e, props, selected) {
    const lwValue = props.lineweight === 'Default' ? 1 : parseFloat(props.lineweight);
    ctx.lineWidth = selected && !state.activeCommand ? lwValue + 1 : lwValue;
    
    const hex = props.color.startsWith('#') ? props.color : '#FFFFFF';
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const alpha = 1.0 - (props.transparency / 100);
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

    const linetype = state.linetypes.find(lt => lt.name === props.linetype);
    if(linetype && linetype.pattern.length > 0) {
        ctx.setLineDash(linetype.pattern.map(p => p * (props.linetypeScale || 1.0)));
    } else {
        ctx.setLineDash([]);
    }

    if (e.type === 'line') {
        ctx.beginPath();
        const p1 = worldToScreen(e.a); const p2 = worldToScreen(e.b);
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    } else if (e.type === 'circle') {
        const center_s = worldToScreen(e.c);
        const edge_w = { x: e.c.x + e.r, y: e.c.y }; // A point on the edge in world coords
        const edge_s = worldToScreen(edge_w);
        const radius_s = distScreen(center_s, edge_s);
        ctx.beginPath();
        ctx.arc(center_s.x, center_s.y, radius_s, 0, Math.PI * 2);
        ctx.stroke();
    } else if (e.type === 'polyline' && e.pts.length > 1) {
        ctx.beginPath();
        const p1 = worldToScreen(e.pts[0]); ctx.moveTo(p1.x, p1.y);
        for(let i=1; i<e.pts.length; i++) { const p2 = worldToScreen(e.pts[i]); ctx.lineTo(p2.x, p2.y); }
        ctx.stroke();
    } else if (e.type === 'text' || e.type === 'mtext') {
        ctx.setLineDash([]);
        const p_s = worldToScreen(e.insertionPoint);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

        const p_top_world = { x: e.insertionPoint.x, y: e.insertionPoint.y + e.height };
        const p_top_screen = worldToScreen(p_top_world);
        const screenPixelHeight = distScreen(p_s, p_top_screen);
        
        if (screenPixelHeight < 1) return; // Don't draw tiny text

        ctx.font = `bold ${screenPixelHeight}px sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';

        ctx.save();
        ctx.translate(p_s.x, p_s.y);
        ctx.rotate(-(e.rotation || 0) * Math.PI / 180);
        
        if (e.type === 'mtext') {
            const width_w = {x: e.insertionPoint.x + e.width, y: e.insertionPoint.y};
            const width_s_pt = worldToScreen(width_w);
            const width_s = distScreen(p_s, width_s_pt);
            
            const lines = e.textString.split('\n');
            let currentY = 0;
            lines.forEach(line => {
                let words = line.split(' ');
                let currentLine = '';
                for(let n = 0; n < words.length; n++) {
                    let testLine = currentLine + words[n] + ' ';
                    let metrics = ctx.measureText(testLine);
                    if (metrics.width > width_s && n > 0) {
                        ctx.fillText(currentLine, 0, currentY);
                        currentLine = words[n] + ' ';
                        currentY -= screenPixelHeight * 1.2;
                    } else {
                        currentLine = testLine;
                    }
                }
                ctx.fillText(currentLine, 0, currentY);
                currentY -= screenPixelHeight * 1.2;
            });
        } else {
            ctx.fillText(e.textString, 0, 0);
        }
        
        ctx.restore();
    }
  }

  function drawSelectionBox() {
    if (!state.selectionBox || !state.selectionBox.start || !state.selectionBox.end) return;

    const { start, end, type } = state.selectionBox;
    const x = Math.min(start.x, end.x);
    const y = Math.min(start.y, end.y);
    const w = Math.abs(start.x - end.x);
    const h = Math.abs(start.y - end.y);

    if (type === 'window') {
        ctx.fillStyle = 'rgba(0, 128, 255, 0.2)';
        ctx.strokeStyle = 'rgba(0, 128, 255, 1)';
        ctx.setLineDash([]);
    } else {
        ctx.fillStyle = 'rgba(0, 255, 128, 0.2)';
        ctx.strokeStyle = 'rgba(0, 255, 128, 1)';
        ctx.setLineDash([5, 3]);
    }

    ctx.lineWidth = 1;
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    ctx.setLineDash([]);
  }

  function drawSelectionGrips() {
      if (state.selection.length === 0 || state.activeCommand) return;
      
      ctx.globalAlpha = 1.0; 

      ctx.setLineDash([]);
      const gripSize = 8;

      ctx.strokeStyle = '#00FF00';
      ctx.lineWidth = 1;

      for (const id of state.selection) {
          const ent = state.ents.find(e => e.id === id);
          if (!ent) continue;

          const grips = getGripsForEnt(ent);
          for (let i = 0; i < grips.length; i++) {
              if (ent.type === 'polyline' && ent.closed && i === grips.length - 1) continue;

              const ptS = worldToScreen(grips[i]);

              if (state.activeGrip && state.activeGrip.entId === id && state.activeGrip.ptIndex === i) {
                  ctx.fillStyle = 'var(--grip-active)';
              } else {
                  ctx.fillStyle = 'var(--accent)';
              }
              
              const gripX = Math.floor(ptS.x - gripSize / 2);
              const gripY = Math.floor(ptS.y - gripSize / 2);

              ctx.fillRect(gripX, gripY, gripSize, gripSize);
              ctx.strokeRect(gripX, gripY, gripSize, gripSize);
          }
      }
  }

  function drawTemporaryGeometry() {
      if (!state.activeCommand) return;
      const { name, data } = state.activeCommand;
      const currentPt = getPointInput();

      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 1;
      ctx.setLineDash([]);

      if (name === 'line' && data.start) {
          const p1 = worldToScreen(data.start); const p2 = worldToScreen(currentPt);
          ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      } else if (name === 'distance' && data.start) {
          const p1 = worldToScreen(data.start); 
          const p2 = worldToScreen(currentPt);
          ctx.beginPath(); 
          ctx.moveTo(p1.x, p1.y); 
          ctx.lineTo(p2.x, p2.y); 
          ctx.stroke();
          const dist = Math.hypot(currentPt.x - data.start.x, currentPt.y - data.start.y);
          showTooltip(`Distance: ${dist.toFixed(4)} ft`);
      } else if (name === 'polyline' && data.points.length > 0) {
          ctx.beginPath();
          const startScreenPt = worldToScreen(data.points[0]);
          ctx.moveTo(startScreenPt.x, startScreenPt.y);
          for (let i = 1; i < data.points.length; i++) {
              ctx.lineTo(worldToScreen(data.points[i]).x, worldToScreen(data.points[i]).y);
          }
          ctx.lineTo(worldToScreen(currentPt).x, worldToScreen(currentPt).y);
          ctx.stroke();
      } else if (name === 'mirror' && data.p1) {
            const p1 = worldToScreen(data.p1); const p2 = worldToScreen(currentPt);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      }

      ctx.strokeStyle = '#FFFF00';
      ctx.setLineDash([5, 5]);

      if (name === 'rect' && data.start) {
          const p1_s = worldToScreen(data.start);
          const p2_s = worldToScreen(currentPt);
          ctx.beginPath();
          ctx.rect(p1_s.x, p1_s.y, p2_s.x - p1_s.x, p2_s.y - p1_s.y);
          ctx.stroke();
      } else if (name === 'mtext' && data.p1) {
          const p1_s = worldToScreen(data.p1);
          const p2_s = worldToScreen(currentPt);
          ctx.beginPath();
          ctx.rect(p1_s.x, p1_s.y, p2_s.x - p1_s.x, p2_s.y - p1_s.y);
          ctx.stroke();
      } else if (name === 'imagetext' && data.p1_screen) {
          const p1 = data.p1_screen;
          const p2 = worldToScreen(currentPt);
          ctx.beginPath();
          ctx.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
          ctx.stroke();
      } else if (name === 'zoom' && data.p1) {
          const p1_s = worldToScreen(data.p1);
          const p2_s = worldToScreen(currentPt);
          ctx.beginPath();
          ctx.rect(p1_s.x, p1_s.y, p2_s.x - p1_s.x, p2_s.y - p1_s.y);
          ctx.stroke();
      } else if (name === 'maptocad' && data.p1_screen) {
          const p1 = data.p1_screen;
          const p2_s = worldToScreen(currentPt);
          ctx.beginPath();
          ctx.rect(p1.x, p1.y, p2_s.x - p1.x, p2_s.y - p1.y);
          ctx.stroke();
      } else if (name === 'circle' && data.center) {
          const radiusInFeet = Math.hypot(currentPt.x - data.center.x, currentPt.y - data.center.y);
          const center_s = worldToScreen(data.center);
          const edge_w = {x: data.center.x + radiusInFeet, y: data.center.y};
          const edge_s = worldToScreen(edge_w);
          const radius_s = distScreen(center_s, edge_s);
          ctx.beginPath();
          ctx.arc(center_s.x, center_s.y, radius_s, 0, Math.PI * 2);
          ctx.stroke();
      } else if ((name === 'move' || name === 'copy') && data.base) {
          const dx = currentPt.x - data.base.x; const dy = currentPt.y - data.base.y;
          const moveFunc = p => ({ x: p.x + dx, y: p.y + dy });
          for (const id of state.selection) {
              const ent = state.ents.find(e => e.id === id); if (!ent) continue;
              const previewEnt = JSON.parse(JSON.stringify(ent));
              transformPoints(previewEnt, moveFunc);
              drawEnt(previewEnt, { color: '#FFFF00', lineweight: 'Default', linetype: 'Continuous', transparency: 0 }, false);
          }
      } else if (name === 'paste' && state.clipboard.basePoint) {
           const { data: clipboardEnts, basePoint } = state.clipboard;
           const dx = currentPt.x - basePoint.x;
           const dy = currentPt.y - basePoint.y;
           const moveFunc = p => ({ x: p.x + dx, y: p.y + dy });
           for (const ent of clipboardEnts) {
               const previewEnt = JSON.parse(JSON.stringify(ent));
               transformPoints(previewEnt, moveFunc);
               drawEnt(previewEnt, { color: '#999', lineweight: 'Default', linetype: 'Continuous', transparency: 0 }, false);
           }
      } else if ((name === 'rotate' || name === 'scale') && data.base && data.ref) {
          const base_s = worldToScreen(data.base); const ref_s = worldToScreen(data.ref); const current_s = worldToScreen(currentPt);
          const v_ref = { x: ref_s.x - base_s.x, y: ref_s.y - base_s.y };
          const v_dest = { x: current_s.x - base_s.x, y: current_s.y - base_s.y };
          const len_ref = Math.hypot(v_ref.x, v_ref.y); if (len_ref < 1) return;
          const len_dest = Math.hypot(v_dest.x, v_dest.y);
          const scaleFactor = (name === 'scale') ? (len_dest / len_ref) : 1.0;
          const angleRad = (name === 'rotate') ? (Math.atan2(v_dest.y, v_dest.x) - Math.atan2(v_ref.y, v_ref.x)) : 0.0;
          const cosA = Math.cos(angleRad); const sinA = Math.sin(angleRad);
          const transformFunc = (p_world) => {
              const p_s = worldToScreen(p_world);
              const dx = p_s.x - base_s.x; const dy = p_s.y - base_s.y;
              const scaled_dx = dx * scaleFactor; const scaled_dy = dy * scaleFactor;
              const new_dx = scaled_dx * cosA - scaled_dy * sinA;
              const new_dy = scaled_dx * sinA + scaled_dy * cosA;
              return screenToWorld({ x: base_s.x + new_dx, y: base_s.y + new_dy });
          };
          for (const id of state.selection) {
              const ent = state.ents.find(e => e.id === id); if (!ent) continue;
              const previewEnt = JSON.parse(JSON.stringify(ent));
              transformPoints(previewEnt, transformFunc);
              if (previewEnt.type === 'circle' && name === 'scale') { previewEnt.r *= scaleFactor; }
              drawEnt(previewEnt, { color: '#999', lineweight: 'Default', linetype: 'Continuous', transparency: 0 }, false);
          }
      }

      ctx.setLineDash([]);
  }


  function drawGrid() {
      if(!state.grid) return;
      const canvasWrap = document.getElementById('canvasWrap');
      canvasWrap.style.background = 'var(--bg)';
  }

  function drawSnapMarker() {
      if(!state.snapPoint) return;
      const markerSize = 12;
      const ptS = worldToScreen(state.snapPoint);
      ctx.strokeStyle = 'var(--osnap-marker)'; ctx.lineWidth = 2;
      ctx.beginPath();
      const {x, y, type} = {...ptS, type: state.snapPoint.type};
      if (type === 'endpoint') ctx.rect(x - markerSize/2, y - markerSize/2, markerSize, markerSize);
      else if (type === 'midpoint') { ctx.moveTo(x, y - markerSize/2); ctx.lineTo(x + markerSize/2, y + markerSize/2); ctx.lineTo(x - markerSize/2, y + markerSize/2); ctx.closePath(); }
      else if (type === 'center') ctx.arc(x, y, markerSize/2, 0, Math.PI*2);
      ctx.stroke();
  }

  function drawCrosshairCursor() {
    if (state.mouse.isPanning) return;
    const { x, y } = state.mouse;
    const color = '#0000FF';
    const pickboxSize = 15;
    const crosshairLength = 105;
    const gap = 3;

    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.setLineDash([]);

    ctx.strokeRect( Math.floor(x - pickboxSize / 2) + 0.5,  Math.floor(y - pickboxSize / 2) + 0.5,  pickboxSize,  pickboxSize );
    ctx.beginPath();
    ctx.moveTo(Math.floor(x + pickboxSize / 2 + gap), Math.floor(y) + 0.5);
    ctx.lineTo(Math.floor(x + pickboxSize / 2 + gap + crosshairLength), Math.floor(y) + 0.5);
    ctx.moveTo(Math.floor(x - pickboxSize / 2 - gap), Math.floor(y) + 0.5);
    ctx.lineTo(Math.floor(x - pickboxSize / 2 - gap - crosshairLength), Math.floor(y) + 0.5);
    ctx.moveTo(Math.floor(x) + 0.5, Math.floor(y + pickboxSize / 2 + gap));
    ctx.lineTo(Math.floor(x) + 0.5, Math.floor(y + pickboxSize / 2 + gap + crosshairLength));
    ctx.moveTo(Math.floor(x) + 0.5, Math.floor(y - pickboxSize / 2 - gap));
    ctx.lineTo(Math.floor(x) + 0.5, Math.floor(y - pickboxSize / 2 - gap - crosshairLength));
    ctx.stroke();
  }

  function evaluateSnaps() {
      state.snapPoint = null;
      if(!state.osnap) return;
      const snapDist = 10; // pixels
      let bestDist = snapDist;
      const mouseS = {x:state.mouse.x, y:state.mouse.y};
      let bestSnapW = null;

      for(const ent of state.ents) {
          if (ent.type === 'line') {
              checkSnap(ent.a, 'endpoint'); checkSnap(ent.b, 'endpoint');
              const mid = {x: (ent.a.x+ent.b.x)/2, y: (ent.a.y+ent.b.y)/2}; checkSnap(mid, 'midpoint');
          } else if (ent.type === 'circle') { checkSnap(ent.c, 'center');
          } else if (ent.type === 'polyline') {
              for (let i = 0; i < ent.pts.length; i++) {
                  checkSnap(ent.pts[i], 'endpoint');
                  if (i > 0) { const mid = {x: (ent.pts[i-1].x + ent.pts[i].x)/2, y: (ent.pts[i-1].y + ent.pts[i].y)/2}; checkSnap(mid, 'midpoint'); }
              }
          }
      }
      function checkSnap(ptW, type) {
        const ptS = worldToScreen(ptW); const d = distScreen(ptS, mouseS);
        if (d < bestDist) { bestDist = d; bestSnapW = {...ptW, type}; }
      }
      state.snapPoint = bestSnapW;
  }

  const pushEnt = (ent) => { if(!ent.id) ent.id=nextId++; state.ents.push(ent); snapshot(); return ent; };
  const hitTest = (p) => {
    let best=null, bd = 8;
    const pS = worldToScreen(p);
    for(const e of [...state.ents].reverse()){
      let d = Infinity;
      if(e.type==='line') { const aS=worldToScreen(e.a), bS=worldToScreen(e.b); const l2=(bS.x-aS.x)**2+(bS.y-aS.y)**2; if (l2===0){ d=distScreen(pS, aS);} else {let t=((pS.x-aS.x)*(bS.x-aS.x)+(pS.y-aS.y)*(bS.y-aS.y))/l2; t=clamp(t,0,1); d = distScreen(pS, {x:aS.x+t*(bS.x-aS.x), y:aS.y+t*(bS.y-aS.y)});}}
      else if(e.type==='circle') {
          const cS = worldToScreen(e.c);
          const edgeW = { x: e.c.x + e.r, y: e.c.y };
          const edgeS = worldToScreen(edgeW);
          const rS = distScreen(cS, edgeS);
          d = Math.abs(distScreen(pS, cS) - rS);
      }
      else if(e.type==='polyline' && e.pts.length > 1) {
          for (let i = 0; i < e.pts.length - 1; i++) {
              const aS=worldToScreen(e.pts[i]), bS=worldToScreen(e.pts[i+1]); const l2=(bS.x-aS.x)**2+(bS.y-aS.y)**2; if(l2===0) continue; let t=((pS.x-aS.x)*(bS.x-aS.x)+(pS.y-aS.y)*(bS.y-aS.y))/l2; t=clamp(t,0,1); const current_d = distScreen(pS, {x:aS.x+t*(bS.x-aS.x), y:aS.y+t*(bS.y-aS.y)}); d = Math.min(d, current_d);
          }
      } else if (e.type === 'text' || e.type === 'mtext') {
          const ptS = worldToScreen(e.insertionPoint);
          const p_top_world = { x: e.insertionPoint.x, y: e.insertionPoint.y + e.height };
          const p_top_screen = worldToScreen(p_top_world);
          const screenPixelHeight = distScreen(ptS, p_top_screen);
          
          ctx.font = `bold ${screenPixelHeight}px sans-serif`;
          const textMetrics = ctx.measureText(e.textString.split('\n')[0]);
          const textRect = { x: ptS.x, y: ptS.y - screenPixelHeight, width: textMetrics.width, height: screenPixelHeight };
          if(pS.x >= textRect.x && pS.x <= textRect.x + textRect.width && pS.y >= textRect.y && pS.y <= textRect.y + textRect.height) {
              d = 0;
          }
      }
      if(d<bd){ bd=d; best=e; }
    }
    return best;
  }
  const isSelected = (id) => state.selection.includes(id);
  const toggleSelect = (id, on) => {
      if(on){ if(!isSelected(id)) state.selection.push(id); }
      else{ state.selection = state.selection.filter(i=>i!==id); }
      updatePropertiesPanel();
  };
  const clearSelection = () => {
      if(state.selection.length > 0) {
          state.selection.length = 0;
          updatePropertiesPanel();
          draw();
      }
  }
  const deleteSelection = () => { if (state.selection.length === 0) return; const count = state.selection.length; state.ents = state.ents.filter(e => !isSelected(e.id)); clearSelection(); snapshot(); logToHistory(`${count} object(s) erased.`); draw(); }

  function isPointInRect(p, r) {
      return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
  }
  function lineIntersectsLine(p1, p2, p3, p4) {
      const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
      if (d === 0) return false;
      const t = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
      const u = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }
  function isEntInSelectionBox(ent, r, isCrossing) {
      if (ent.type === 'line') {
          const aS = worldToScreen(ent.a); const bS = worldToScreen(ent.b);
          if (isCrossing) {
              if (isPointInRect(aS, r) || isPointInRect(bS, r)) return true;
              const r_tl = { x: r.x, y: r.y }, r_tr = { x: r.x + r.w, y: r.y };
              const r_bl = { x: r.x, y: r.y + r.h }, r_br = { x: r.x + r.w, y: r.y + r.h };
              if (lineIntersectsLine(aS, bS, r_tl, r_tr) || lineIntersectsLine(aS, bS, r_tr, r_br) || lineIntersectsLine(aS, bS, r_br, r_bl) || lineIntersectsLine(aS, bS, r_bl, r_tl)) return true;
              return false;
          } else { return isPointInRect(aS, r) && isPointInRect(bS, r); }
      } else if (ent.type === 'polyline') {
          const ptsS = ent.pts.map(p => worldToScreen(p));
          if (isCrossing) {
              for (let i = 0; i < ptsS.length - 1; i++) { if (isEntInSelectionBox({ type: 'line', a: ent.pts[i], b: ent.pts[i + 1] }, r, true)) return true; }
              return false;
          } else { return ptsS.every(p => isPointInRect(p, r)); }
      } else if (ent.type === 'circle') {
          const cS = worldToScreen(ent.c);
          const edgeW = {x: ent.c.x + ent.r, y: ent.c.y};
          const edgeS = worldToScreen(edgeW);
          const rS = distScreen(cS, edgeS);
          const ent_r = { x: cS.x - rS, y: cS.y - rS, w: 2 * rS, h: 2 * rS };
          if (isCrossing) { return !(r.x > ent_r.x + ent_r.w || r.x + r.w < ent_r.x || r.y > ent_r.y + ent_r.h || r.y + r.h < ent_r.y); }
          else { return ent_r.x >= r.x && ent_r.x + ent_r.w <= r.x + r.w && ent_r.y >= r.y && ent_r.y + ent_r.h <= r.y + r.h; }
      } else if (ent.type === 'text' || ent.type === 'mtext') {
          const pS = worldToScreen(ent.insertionPoint);
          if (isCrossing) { return isPointInRect(pS, r); }
          else { return isPointInRect(pS, r); }
      }
      return false;
  }
  function finalizeSelectionBox() {
      const { start, end, type } = state.selectionBox;
      const rect = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(start.x - end.x), h: Math.abs(start.y - end.y) };
      const isCrossing = type === 'crossing';
      for (const ent of state.ents) {
          if (isEntInSelectionBox(ent, rect, isCrossing)) { toggleSelect(ent.id, true); }
      }
  }

    function finalizeStretchSelection() {
        const { start, end } = state.selectionBox;
        if (end.x > start.x) {
            logToHistory("Stretch requires a crossing window (right to left).");
            cancelCommand();
            return;
        }

        const rect = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(start.x - end.x), h: Math.abs(start.y - end.y) };
        const cmd = state.activeCommand;
        cmd.data.vertsToStretch = [];

        for (const ent of state.ents) {
            if(ent.type !== 'line' && ent.type !== 'polyline') continue;
            const grips = getGripsForEnt(ent);
            const verticesInWindow = [];
            grips.forEach((grip, index) => {
                const grip_s = worldToScreen(grip);
                if (isPointInRect(grip_s, rect)) {
                    verticesInWindow.push(index);
                }
            });

            if (verticesInWindow.length > 0) {
                 if (ent.type === 'polyline' && verticesInWindow.length === grips.length) continue;
                 cmd.data.vertsToStretch.push({ ent, vertices: verticesInWindow });
            }
        }
        if (cmd.data.vertsToStretch.length > 0) {
            logToHistory(`${cmd.data.vertsToStretch.length} object(s) selected for stretch.`);
            setPrompt("Specify base point:");
            cmd.step = 2;
        } else {
            logToHistory("No vertices selected to stretch.");
            cancelCommand();
        }
    }

  // =======================================================
  // SECTION: GRIP EDITING LOGIC
  // =======================================================

  function getGripsForEnt(ent) {
      if (ent.type === 'line') return [ent.a, ent.b];
      if (ent.type === 'polyline') return ent.pts;
      if (ent.type === 'text') return [ent.insertionPoint];
      if (ent.type === 'mtext') {
          const p2 = getDestinationPoint(ent.insertionPoint, ent.width, ent.rotation);
          return [ent.insertionPoint, p2];
      }
      if (ent.type === 'circle') {
          const quads = [
              getDestinationPoint(ent.c, ent.r, 0),
              getDestinationPoint(ent.c, ent.r, 90),
              getDestinationPoint(ent.c, ent.r, 180),
              getDestinationPoint(ent.c, ent.r, 270),
          ];
          return [ent.c, ...quads];
      }
      return [];
  }

  function gripHitTest(worldPt) {
      const gripScreenRadius = 8;
      const ptS = worldToScreen(worldPt);
      for (const id of state.selection) {
          const ent = state.ents.find(e => e.id === id);
          if (!ent) continue;

          const grips = getGripsForEnt(ent);
          for (let i = 0; i < grips.length; i++) {
              const gripS = worldToScreen(grips[i]);
              if (distScreen(ptS, gripS) < gripScreenRadius) {
                  return { entId: id, ptIndex: i };
              }
          }
      }
      return null;
  }

  function startGripEdit(gripHit) {
      const ent = state.ents.find(e => e.id === gripHit.entId);
      if (!ent) return;
      state.activeGrip = {
          entId: gripHit.entId,
          ptIndex: gripHit.ptIndex,
          originalEnt: JSON.parse(JSON.stringify(ent))
      };
      logToHistory("Grip edit started (STRETCH).");
      setPrompt("Specify new point location...");
      draw();
  }

  function finalizeGripEdit() {
      if (!state.activeGrip) return;
      logToHistory("Grip edit finalized.");
      state.activeGrip = null;
      snapshot();
      setPrompt("Command: ");
      draw();
  }

  function cancelGripEdit() {
      if (!state.activeGrip) return;
      const index = state.ents.findIndex(e => e.id === state.activeGrip.entId);
      if (index !== -1) {
          state.ents[index] = state.activeGrip.originalEnt;
      }
      logToHistory("*Cancel* Grip edit canceled.");
      state.activeGrip = null;
      setPrompt("Command: ");
      draw();
  }

  function updateEntityWithNewGrip(ent, ptIndex, newPt) {
      if (ent.type === 'line') {
          if (ptIndex === 0) ent.a = newPt;
          else ent.b = newPt;
      } else if (ent.type === 'polyline') {
          ent.pts[ptIndex] = newPt;
          if (ent.closed && (ptIndex === 0 || ptIndex === ent.pts.length - 1)) {
              ent.pts[0] = newPt;
              ent.pts[ent.pts.length - 1] = newPt;
          }
      } else if (ent.type === 'text') {
          if (ptIndex === 0) ent.insertionPoint = newPt;
      } else if (ent.type === 'mtext') {
const p1 = ent.insertionPoint;
const p2 = getDestinationPoint(p1, ent.width, 90);
if(ptIndex === 0) { // Moving insertion point
ent.insertionPoint = newPt;
ent.width = L.latLng(newPt.y, newPt.x).distanceTo(L.latLng(p2.y, p2.x));
} else { // Adjusting width
ent.width = L.latLng(p1.y, p1.x).distanceTo(L.latLng(newPt.y, newPt.x));
}
      } else if (ent.type === 'circle') {
          if (ptIndex === 0) {
              ent.c = newPt;
          } else {
              ent.r = Math.hypot(newPt.x - ent.c.x, newPt.y - ent.c.y);
          }
      }
  }


    // =======================================================
    // SECTION: CONTEXT MENU
    // =======================================================

    function showContextMenu(x, y, gripHit) {
        contextMenu.innerHTML = ''; // Clear previous items
        const ent = state.ents.find(e => e.id === gripHit.entId);
        if (!ent) return;

        if (ent.type === 'polyline' && ent.pts.length > 1) {
            const button = document.createElement('button');
            button.textContent = 'Add Vertex';
            button.onclick = () => {
                addVertex(gripHit.entId, gripHit.ptIndex);
                hideContextMenu();
            };
            contextMenu.appendChild(button);
        }

        if (contextMenu.children.length > 0) {
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';
        }
    }

    function hideContextMenu() {
        contextMenu.style.display = 'none';
    }

    function addVertex(entId, ptIndex) {
        const ent = state.ents.find(e => e.id === entId);
        if (!ent || ent.type !== 'polyline') return;

        let p1_idx, p2_idx;
        if (ptIndex === 0) {
            if (ent.closed) {
                p1_idx = ent.pts.length - 2; // Second to last point
                p2_idx = 0;
            } else {
                return; // Can't add before the start of an open polyline
            }
        } else {
            p1_idx = ptIndex - 1;
            p2_idx = ptIndex;
        }

        const p1 = ent.pts[p1_idx];
        const p2 = ent.pts[p2_idx];
        const newVertex = {
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2
        };

        ent.pts.splice(p2_idx, 0, newVertex);

        logToHistory("Vertex added to polyline.");
        snapshot();
        draw();
    }


  // =======================================================
  // SECTION: UI & STATE HELPERS
  // =======================================================
  function copyToClipboard() {
      if (state.selection.length === 0) {
          logToHistory("Nothing selected to copy to clipboard.");
          return;
      }
      state.clipboard.data = state.selection.map(id => {
          const ent = state.ents.find(e => e.id === id);
          return JSON.parse(JSON.stringify(ent));
      });

      // Calculate a base point from the selection's bounding box center
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for(const id of state.selection) {
          const ent = state.ents.find(e => e.id === id);
          if(!ent) continue;
          const grips = getGripsForEnt(ent);
          for(const pt of grips) {
              minX = Math.min(minX, pt.x);
              minY = Math.min(minY, pt.y);
              maxX = Math.max(maxX, pt.x);
              maxY = Math.max(maxY, pt.y);
          }
      }
      state.clipboard.basePoint = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };

      logToHistory(`${state.selection.length} object(s) copied to clipboard.`);
  }

  function toggleState(mode) { state[mode] = !state[mode]; logToHistory(`${mode.toUpperCase()} <${state[mode] ? 'ON' : 'OFF'}>`); updateStatusBar(); draw(); }
  
  function toggleMap() {
      mapState = (mapState + 1) % 3; // Cycle through 0, 1, 2
      
      leafletMap.removeLayer(mapTileLayerSatellite);
      leafletMap.removeLayer(mapTileLayerStreet);
      const canvasWrap = document.getElementById('canvasWrap');
      const toggleBtn = document.getElementById('toggleMapBtn');

      switch (mapState) {
          case 0: // Off
              canvas.style.backgroundColor = 'var(--bg)';
              canvasWrap.style.background = 'var(--bg)';
              toggleBtn.textContent = 'üõ∞Ô∏è';
              toggleBtn.title = 'Show Satellite Map';
              logToHistory("Map hidden.");
              break;
          case 1: // Satellite
              mapTileLayerSatellite.addTo(leafletMap);
              canvas.style.backgroundColor = 'transparent';
              canvasWrap.style.background = 'transparent';
              toggleBtn.textContent = 'üó∫Ô∏è';
              toggleBtn.title = 'Switch to Street Map';
              logToHistory("Satellite map enabled.");
              break;
          case 2: // Street
              mapTileLayerStreet.addTo(leafletMap);
              canvas.style.backgroundColor = 'transparent';
               canvasWrap.style.background = '#FFFFFF';
              toggleBtn.textContent = 'üö´';
              toggleBtn.title = 'Hide Map Tiles';
              logToHistory("Street map enabled.");
              break;
      }
      draw();
  }

  function updateStatusBar() { const t = (id, a) => document.getElementById(id).classList.toggle('active',a); t('gridToggle', state.grid); t('orthoToggle', state.ortho); t('osnapToggle', state.osnap); }
  function resize() { const r=canvas.parentElement.getBoundingClientRect(); canvas.width=r.width; canvas.height=r.height; if(leafletMap) leafletMap.invalidateSize(); draw(); }
  function updateTooltipPosition(e) { tooltip.style.left = `${e.clientX + 20}px`; tooltip.style.top = `${e.clientY + 20}px`; }
  function showTooltip(text) { if(state.activeCommand || state.activeGrip) { tooltip.textContent = text; tooltip.style.display = 'block'; } }
  function hideTooltip() { tooltip.style.display = 'none'; }

  function updatePropertiesPanel() {
      const genericProps = document.getElementById('propGeneric');
      const textProps = document.getElementById('propText');
      const propType = document.getElementById('propType');
      
      const layerSelects = [document.getElementById('propLayer'), document.getElementById('propTextLayer')];
      layerSelects.forEach(select => {
          select.innerHTML = '';
          state.layers.forEach(l => {
              const opt = document.createElement('option');
              opt.value = l.name;
              opt.textContent = l.name;
              select.appendChild(opt);
          });
          select.value = state.currentLayer;
      });

      const showGeneric = () => { genericProps.style.display = 'block'; textProps.style.display = 'none'; };
      const showText = () => { genericProps.style.display = 'none'; textProps.style.display = 'block'; };
      
      if (state.selection.length === 1) {
          const ent = state.ents.find(e => e.id === state.selection[0]);
          if (ent && (ent.type === 'text' || ent.type === 'mtext')) {
              showText();
              document.getElementById('propTextType').value = ent.type.toUpperCase();
              document.getElementById('propTextContent').value = ent.textString;
              document.getElementById('propTextHeight').value = ent.height;
              document.getElementById('propTextRotation').value = ent.rotation || 0;
              document.getElementById('propTextLayer').value = ent.layer;
              const layer = state.layers.find(l => l.name === ent.layer);
              const effectiveColor = (ent.props && ent.props.color && ent.props.color !== 'ByLayer')
                  ? ent.props.color
                  : (layer ? layer.color : '#e6e9ef');
              document.getElementById('propTextColor').value = effectiveColor;            
              return;
          }
      }
      
      showGeneric();
      propType.value = state.selection.length === 0 ? 'No selection' : `Multiple (${state.selection.length})`;

      if (state.selection.length === 0) {
          document.getElementById('propColor').value = state.currentProperties.color;
          document.getElementById('propLinetype').value = state.currentProperties.linetype;
          document.getElementById('propLinetypeScale').value = state.currentProperties.linetypeScale;
          document.getElementById('propLineweight').value = state.currentProperties.lineweight;
          document.getElementById('propTransparency').value = state.currentProperties.transparency;
          document.getElementById('propThickness').value = state.currentProperties.thickness;
      } else {
          // Simplified for multiple selection
          const firstEnt = state.ents.find(e => e.id === state.selection[0]);
          if (firstEnt) {
              document.getElementById('propLayer').value = firstEnt.layer;
              document.getElementById('propColor').value = firstEnt.props.color || '#ffffff';
          }
      }
  }
  
  function updateSelectedText(targetId, value) {
      if (state.selection.length !== 1) return;
      const ent = state.ents.find(e => e.id === state.selection[0]);
      if (!ent || (ent.type !== 'text' && ent.type !== 'mtext')) return;
      
      switch (targetId) {
          case 'propTextContent':
              ent.textString = value;
              break;
          case 'propTextHeight':
              const newWorldHeight = parseFloat(value);
              if (!isNaN(newWorldHeight) && newWorldHeight > 0) {
                  ent.height = newWorldHeight;
              }
              break;
          case 'propTextRotation':
              const newRotation = parseFloat(value);
              if (!isNaN(newRotation)) {
                  ent.rotation = newRotation;
              }
              break;
          case 'propTextLayer':
               ent.layer = value;
               break;
          case 'propTextColor':
               if (!ent.props) ent.props = {};
               ent.props.color = value;
               break;
      }
      snapshot();
      draw();
  }


  function updateSelectedEnts(prop, value) {
      if (state.selection.length === 0) return;
      state.selection.forEach(id => {
          const ent = state.ents.find(e => e.id === id);
          if (!ent) return;
          if (prop === 'layer') {
              ent.layer = value;
          } else {
              if (!ent.props) ent.props = {};
              if (prop === 'linetypescale' || prop === 'transparency' || prop === 'thickness') {
                   ent.props[prop] = parseFloat(value);
              } else {
                   ent.props[prop] = value;
              }
          }
      });
      snapshot();
      draw();
  }

  function refreshLayersUI(){
      layersDiv.innerHTML = '';
      const propLayerSelects = [document.getElementById('propLayer'), document.getElementById('propTextLayer')];
      propLayerSelects.forEach(select => {
          select.innerHTML = '';
          state.layers.forEach(l => {
              const row = document.createElement('div');
              if (select.id === 'propLayer') { // Only add to the main layer list once
                  row.className = 'layer-row';
                  row.innerHTML = `<input type="checkbox" data-name="${l.name}" data-prop="visible" ${l.visible ? 'checked' : ''}><input type="color" data-name="${l.name}" data-prop="color" value="${l.color}"><span>${l.name}</span>`;
                  layersDiv.appendChild(row);
              }
              const opt = document.createElement('option');
              opt.value = l.name;
              opt.textContent = l.name;
              select.appendChild(opt);
          });
      });
      updatePropertiesPanel();
  }

  function addLayer(){
      const nameInput = document.getElementById('newLayerName'); const name = nameInput.value.trim();
      if (!name) { alert("Layer name cannot be empty."); return; }
      if (state.layers.some(l => l.name.toLowerCase() === name.toLowerCase())) { alert("Layer name already exists."); return; }
      state.layers.push({ name, color: '#ffffff', visible: true, locked: false }); state.currentLayer = name;
      nameInput.value = ''; snapshot(); refreshLayersUI();
  }
  function onLayerChange(e) {
      const t = e.target; const n=t.dataset.name, p=t.dataset.prop; const l=state.layers.find(l=>l.name===n); if(!l)return;
      if(p==='visible') l.visible=t.checked; else if (p==='color') l.color=t.value;
      snapshot(); draw();
  }
  function curProps() {
      return { ...state.currentProperties };
  }
  function snapshot(){ const s=JSON.stringify({ents:state.ents, layers:state.layers, currentLayer: state.currentLayer}); if (state.history[state.history.length-1] !== s) { state.history.push(s); if(state.history.length>50)state.history.shift(); state.future=[]; } }
  function loadState(s) {
      try {
        const r = JSON.parse(s);
        state.ents=r.ents||[];
        state.layers=r.layers||[{name:'0',color:'#e6e9ef',visible:true,locked:false}];
        state.currentLayer=r.currentLayer||'0';
        nextId=(state.ents.reduce((m,e)=>Math.max(m,e.id),0)||0)+1;
        refreshLayersUI();
        updateStatusBar();
        draw();
        logToHistory("Drawing loaded successfully.");
      } catch (e) {
        logToHistory("Error: Could not load the file. It might be corrupted or not a valid drawing file.");
        console.error("File loading error:", e);
      }
  }
  function undo() { if(state.history.length<=1)return; state.future.push(state.history.pop()); loadState(state.history[state.history.length-1]); }
  function redo() { if(state.future.length===0)return; const s=state.future.pop(); state.history.push(s); loadState(s); }

  function saveAs(blob, filename) {
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
  }

  function saveDrawing() {
      const data = {
          ents: state.ents,
          layers: state.layers,
          currentLayer: state.currentLayer,
      };
      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], {type: 'application/json'});
      saveAs(blob, 'drawing.json');
      logToHistory("Drawing saved.");
  }

  function openDrawing(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
          const content = e.target.result;
          loadState(content);
          snapshot();
      };
      reader.readAsText(file);
      fileInput.value = '';
  }

  function escapeXml(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;'; case '>': return '&gt;'; case '&': return '&amp;';
            case '\'': return '&apos;'; case '"': return '&quot;';
        }
    });
  }

    function exportToGeoJson(entitiesToExport, filename = 'export.geojson') {
        logToHistory(`Exporting ${entitiesToExport.length} entities to GeoJSON...`);
        
        const worldToLatLng = (p_ft) => {
            const dLat = p_ft.y / feetPerDegree.lat;
            const dLng = p_ft.x / feetPerDegree.lng;
            return L.latLng(cadOrigin.lat + dLat, cadOrigin.lng + dLng);
        };

        const geojson = {
            "type": "FeatureCollection",
            "features": []
        };

        entitiesToExport.forEach(ent => {
            const layer = state.layers.find(l => l.name === ent.layer) || {};
            if (!layer.visible) return;

            let feature = {
                "type": "Feature",
                "geometry": null,
                "properties": {
                    "type": ent.type,
                    "layer": ent.layer,
                    ...ent.props
                }
            };
            
            if (ent.type === 'line') {
                const a = worldToLatLng(ent.a);
                const b = worldToLatLng(ent.b);
                feature.geometry = { "type": "LineString", "coordinates": [[a.lng, a.lat], [b.lng, b.lat]] };
            } else if (ent.type === 'polyline') {
                const coords = ent.pts.map(p => { const ll = worldToLatLng(p); return [ll.lng, ll.lat]; });
                if (ent.closed && coords.length > 3) {
                    feature.geometry = { "type": "Polygon", "coordinates": [coords] };
                } else {
                    feature.geometry = { "type": "LineString", "coordinates": coords };
                }
            } else if (ent.type === 'circle') {
                const segments = 64; 
                let coords = [];
                for (let i = 0; i <= segments; i++) {
                    const angle = (i/segments) * 360;
                    const pt = getDestinationPoint(ent.c, ent.r, angle);
                    const ll = worldToLatLng(pt);
                    coords.push([ll.lng, ll.lat]);
                }
                feature.geometry = { "type": "Polygon", "coordinates": [coords] };
                feature.properties.radius = ent.r;
            } else if (ent.type === 'text' || ent.type === 'mtext') {
                const ll = worldToLatLng(ent.insertionPoint);
                feature.geometry = { "type": "Point", "coordinates": [ll.lng, ll.lat] };
                feature.properties.text = ent.textString;
                feature.properties.height = ent.height;
                feature.properties.rotation = ent.rotation;
                if (ent.type === 'mtext') feature.properties.width = ent.width;
            }
            
            if (feature.geometry) {
                geojson.features.push(feature);
            }
        });
        
        const jsonString = JSON.stringify(geojson, null, 2);
        const blob = new Blob([jsonString], {type: 'application/json'});
        saveAs(blob, filename);
    }


  function exportToKmz(entitiesToExport, filename = 'export.kmz') {
      if(!window.JSZip){alert("JSZip library not found."); return;}
       logToHistory(`Exporting ${entitiesToExport.length} entities to KMZ...`);
      const zip = new JSZip();
      let kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>`;
      state.layers.forEach(layer => { const kmlColor = "ff" + layer.color.substring(5, 7) + layer.color.substring(3, 5) + layer.color.substring(1, 3); kml += `<Style id="layer-${layer.name.replace(/\s/g, '_')}"><LineStyle><color>${kmlColor}</color><width>2</width></LineStyle><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/paddle/wht-blank.png</href></Icon><hotSpot x="0.5" y="0.5" xunits="fraction" yunits="fraction"/></IconStyle></Style>`; });

      entitiesToExport.forEach(ent => {
          const layer = state.layers.find(l => l.name === ent.layer) || state.layers[0]; if (!layer.visible) return;
          const styleUrl = `#layer-${layer.name.replace(/\s/g, '_')}`;

          const worldToLatLng = (p_ft) => {
              const dLat = p_ft.y / feetPerDegree.lat;
              const dLng = p_ft.x / feetPerDegree.lng;
              return L.latLng(cadOrigin.lat + dLat, cadOrigin.lng + dLng);
          };

          if (ent.type === 'line' || ent.type === 'polyline' || ent.type === 'circle') {
            kml += `<Placemark><styleUrl>${styleUrl}</styleUrl><LineString><coordinates>`;
            let coordsStr = '';
            if (ent.type === 'line') {
                const a = worldToLatLng(ent.a); const b = worldToLatLng(ent.b);
                coordsStr = `${a.lng},${a.lat},0 ${b.lng},${b.lat},0`;
            } else if (ent.type === 'polyline') {
                coordsStr = ent.pts.map(p => { const ll = worldToLatLng(p); return `${ll.lng},${ll.lat},0`; }).join(' ');
            } else if (ent.type === 'circle') {
                const segments = 64; let coords = '';
                for (let i = 0; i <= segments; i++) {
                    const angle = (i/segments)*360;
                    const pt = getDestinationPoint(ent.c, ent.r, angle);
                    const ll = worldToLatLng(pt);
                    coords += `${ll.lng},${ll.lat},0 `;
                }
                coordsStr = coords.trim();
            }
            kml += coordsStr + `</coordinates></LineString></Placemark>`;
          } else if (ent.type === 'text' || ent.type === 'mtext') {
            const ll = worldToLatLng(ent.insertionPoint);
            kml += `<Placemark><name>${escapeXml(ent.textString)}</name><styleUrl>${styleUrl}</styleUrl><Point><coordinates>${ll.lng},${ll.lat},0</coordinates></Point></Placemark>`;
          }
      });
      kml += `</Document></kml>`;
      zip.file("doc.kml", kml);
      zip.generateAsync({type:"blob"}).then(function(content) {
          saveAs(content, filename);
      });
  }

  function exportToDxf(entitiesToExport, filename = 'export.dxf') {
    logToHistory(`Exporting ${entitiesToExport.length} entities to DXF... (Units = Feet)`);
    
    class DxfWriter {
        constructor() { this.handleSeed = 100; this.dxf = []; }
        add(code, value) { this.dxf.push(String(code), String(value)); }
        getHandle() { return (this.handleSeed++).toString(16).toUpperCase(); }
        toString() { return this.dxf.join('\n'); }
    }

    const dxf = new DxfWriter();
    const hexToAci = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
        if (r > 200 && g > 200 && b > 200) return 7; if (r > 200 && g < 100 && b < 100) return 1;
        if (g > 200 && r < 100 && b < 100) return 3; if (b > 200 && r < 100 && g < 100) return 5;
        if (r > 200 && g > 200 && b < 100) return 2; return 7;
    };

    dxf.add(0, 'SECTION'); dxf.add(2, 'HEADER');
    dxf.add(9, '$ACADVER'); dxf.add(1, 'AC1009');
    dxf.add(9, '$INSUNITS'); dxf.add(70, 2); // 2 = Feet
    dxf.add(0, 'ENDSEC');
    dxf.add(0, 'SECTION'); dxf.add(2, 'TABLES');
    dxf.add(0, 'TABLE'); dxf.add(2, 'LTYPE');
    dxf.add(0, 'LTYPE'); dxf.add(2, 'Continuous'); dxf.add(70, 64); dxf.add(3, 'Solid line'); dxf.add(72, 65); dxf.add(73, 0); dxf.add(40, 0.0);
    dxf.add(0, 'ENDTAB');
    dxf.add(0, 'TABLE'); dxf.add(2, 'LAYER');
    state.layers.forEach(layer => {
        dxf.add(0, 'LAYER'); dxf.add(2, layer.name); dxf.add(70, 0); dxf.add(62, hexToAci(layer.color)); dxf.add(6, 'Continuous');
    });
    dxf.add(0, 'ENDTAB');
    dxf.add(0, 'ENDSEC');
    dxf.add(0, 'SECTION'); dxf.add(2, 'ENTITIES');

    entitiesToExport.forEach(ent => {
        const layer = state.layers.find(l => l.name === ent.layer);
        if (!layer || !layer.visible) return;

        if (ent.type === 'line') {
            dxf.add(0, 'LINE'); dxf.add(8, ent.layer);
            dxf.add(10, ent.a.x); dxf.add(20, ent.a.y); dxf.add(30, 0);
            dxf.add(11, ent.b.x); dxf.add(21, ent.b.y); dxf.add(31, 0);
        } else if (ent.type === 'polyline' && ent.pts.length > 1) {
            dxf.add(0, 'LWPOLYLINE'); dxf.add(8, ent.layer);
            dxf.add(100, 'AcDbEntity'); dxf.add(100, 'AcDbPolyline');
            dxf.add(90, ent.pts.length); dxf.add(70, ent.closed ? 1 : 0);
            ent.pts.forEach(pt => { dxf.add(10, pt.x); dxf.add(20, pt.y); });
        } else if (ent.type === 'circle') {
            dxf.add(0, 'CIRCLE'); dxf.add(8, ent.layer);
            dxf.add(10, ent.c.x); dxf.add(20, ent.c.y); dxf.add(30, 0);
            dxf.add(40, ent.r);
        } else if (ent.type === 'text' || ent.type === 'mtext') {
            dxf.add(0, 'TEXT'); dxf.add(8, ent.layer);
            dxf.add(10, ent.insertionPoint.x); dxf.add(20, ent.insertionPoint.y); dxf.add(30, 0);
            dxf.add(40, ent.height);
            if (ent.rotation) dxf.add(50, ent.rotation);
            dxf.add(1, ent.textString);
        }
    });
    dxf.add(0, 'ENDSEC');
    dxf.add(0, 'EOF');

    const dxfString = dxf.toString();
    const blob = new Blob([dxfString], { type: 'application/dxf' });
    saveAs(blob, filename);
  }

  function startDownloadManagerExport() {
      const isSplit = document.getElementById('dl-split').checked;
      const visibleEnts = state.ents.filter(ent => (state.layers.find(l => l.name === ent.layer) || {}).visible);
      
      let exportCount = 0;
      const groups = {};
      if (isSplit) {
          visibleEnts.forEach(ent => {
              if (!groups[ent.type]) groups[ent.type] = [];
              groups[ent.type].push(ent);
          });
      }

      const runExport = (exportFunc, fileExtension, baseFilename) => {
          if (isSplit) {
              for (const type in groups) {
                  exportFunc(groups[type], `${baseFilename}-${type}s.${fileExtension}`);
              }
          } else {
              exportFunc(visibleEnts, `${baseFilename}.${fileExtension}`);
          }
      };

      if (document.getElementById('dl-gis').checked) {
          logToHistory("GIS Shapefile export is not implemented. Please use GeoJSON for GIS applications.");
          // Placeholder for future implementation
      }
      if (document.getElementById('dl-kmz').checked) {
          runExport(exportToKmz, 'kmz', 'drawing-kmz');
          exportCount++;
      }
      if (document.getElementById('dl-dxf').checked) {
          runExport(exportToDxf, 'dxf', 'drawing-dxf');
          exportCount++;
      }
      if (document.getElementById('dl-geojson').checked) {
          runExport(exportToGeoJson, 'geojson', 'drawing-geojson');
          exportCount++;
      }
      if (document.getElementById('dl-jobjson').checked) {
          saveDrawing();
          exportCount++;
      }

      if (exportCount === 0) {
          logToHistory("No export formats selected.");
      } else {
          document.getElementById('downloadManagerModal').style.display = 'none';
      }
  }


  // Run the application
  init();
})();
</script>
</body>
</html>